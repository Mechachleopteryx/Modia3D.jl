<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Composition · Modia3D</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Modia3D</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/GettingStarted.html">Getting Started</a></li><li><a class="toctext" href="../man/Examples.html">Examples</a></li><li><a class="toctext" href="../man/Materials.html">Materials</a></li><li><a class="toctext" href="../man/CollisionHandling.html">Collision Handling</a></li><li><a class="toctext" href="../man/Plans.html">Plans</a></li></ul></li><li><span class="toctext">Library</span><ul><li class="current"><a class="toctext" href="Composition.html">Composition</a><ul class="internal"></ul></li><li><a class="toctext" href="Graphics.html">Graphics</a></li><li><a class="toctext" href="Solids.html">Solids</a></li><li><a class="toctext" href="ForceElements.html">ForceElements</a></li><li><a class="toctext" href="Basics.html">Basics</a></li></ul></li><li><span class="toctext">Internal</span><ul><li><a class="toctext" href="../internal/ContactDetection.html">Contact Detection</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href="Composition.html">Composition</a></li></ul><a class="edit-page" href="https://github.com//blob/master/docs/src/lib/Composition.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Composition</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Composition-1" href="#Composition-1">Composition</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition" href="#Modia3D.Composition"><code>Modia3D.Composition</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-julia">module Modia3D.Composition</code></pre><p>Structuring of objects moving in 3D. Most important constructors (dof are the <code>degrees-of-freedom</code>):</p><table><tr><th style="text-align: left">Function</th><th style="text-align: center">dof</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="Composition.html#Modia3D.Composition.@assembly-Tuple{Any,Any}"><code>@assembly</code></a><code>Name(..) begin .. end</code></td><td style="text-align: center">-</td><td style="text-align: left">Return a <code>Name</code> constructor for Object3Ds</td></tr><tr><td style="text-align: left"><a href="Composition.html#Modia3D.Composition.Object3D"><code>Object3D</code></a><code>([data];..)</code></td><td style="text-align: center">0</td><td style="text-align: left">Return a reference Object3D</td></tr><tr><td style="text-align: left"><a href="Composition.html#Modia3D.Composition.Object3D"><code>Object3D</code></a><code>(parent [, data];..)</code></td><td style="text-align: center">0,6</td><td style="text-align: left">Return Object3D fixed/moving w.r.t. <code>parent</code></td></tr><tr><td style="text-align: left"><a href="Composition.html#Modia3D.Composition.Revolute-Tuple{Object3D,Object3D}"><code>Modia3D.Revolute</code></a><code>(obj1,obj2;..)</code></td><td style="text-align: center">1</td><td style="text-align: left">Return a revolute joint</td></tr><tr><td style="text-align: left"><a href="Composition.html#Modia3D.Composition.Prismatic-Tuple{Object3D,Object3D}"><code>Modia3D.Prismatic</code></a><code>(obj1,obj2;..)</code></td><td style="text-align: center">1</td><td style="text-align: left">Return a prismatic joint</td></tr></table><p>The optional <code>data</code> associated with an <code>Object3D</code> can be one of the following:</p><table><tr><th style="text-align: left"><code>data</code></th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>::</code><a href="Solids.html#Modia3D.Solids.Solid"><code>Modia3D.Solid</code></a></td><td style="text-align: left">Solids with geometry, mass, visual/contact material</td></tr><tr><td style="text-align: left"><code>&lt;:Modia3D.AbstractVisualElement</code></td><td style="text-align: left">Visual elements (<a href="Graphics.html#Modia3D.Graphics"><code>Modia3D.Graphics</code></a>)</td></tr></table><p><strong>Main developers</strong></p><p>Andrea Neumayr and Martin Otter, <a href="https://www.dlr.de/sr/en">DLR - Institute of System Dynamics and Control</a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.ContactDetectionMPR_handler" href="#Modia3D.Composition.ContactDetectionMPR_handler"><code>Modia3D.Composition.ContactDetectionMPR_handler</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">handler = ContactDetectionMPR_handler(;tol_rel = 1e-4, niter_max=100, neps=sqrt(eps()))</code></pre><p>Generate a new contact handler for usage of the MPR algorithm The handler instance contains all information about the contact situation.</p><p><strong>Arguments</strong></p><ul><li><code>tol_rel</code>: Relative tolerance to compute the contact point (&gt; 0.0)</li><li><code>niter_max</code>: Maximum number of iterations of the MPR algorithm. If this number is reached,              an error occurs (&gt; 0).</li><li><code>neps</code>: Small number used to check whether a floating number is close to zero (&gt; 0.0).</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.ContactPair" href="#Modia3D.Composition.ContactPair"><code>Modia3D.Composition.ContactPair</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">pair = ContactPair(contactPoint1,contactPoint2,contactNormal,obj1,obj2,
                   distanceWithHysteresis)</code></pre><p>Generate a new <code>ContactPair</code> object of two objects that have contact=true.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.ElasticContactPairResponseMaterial" href="#Modia3D.Composition.ElasticContactPairResponseMaterial"><code>Modia3D.Composition.ElasticContactPairResponseMaterial</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">m = ElasticContactPairResponseMaterial(c_res, d_res, mu_k, mu_r, vsmall, wsmall)</code></pre><p>Return an <code>ElasticContactPairResponseMaterial &lt; AbstractContactPairMaterial</code> object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.NoContactPair" href="#Modia3D.Composition.NoContactPair"><code>Modia3D.Composition.NoContactPair</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">pair = NoContactPair(contactPoint1,contactPoint2,contactNormal,obj1,obj2,
                     distanceWithHysteresis)</code></pre><p>Generate a new <code>NoContactPair</code> object of two objects that have contact=false.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.NoGravityField" href="#Modia3D.Composition.NoGravityField"><code>Modia3D.Composition.NoGravityField</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">gravityField = NoGravityField()</code></pre><p>Generate an instance of type <code>NoGravityField</code> that defines no gravity.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.Object3D" href="#Modia3D.Composition.Object3D"><code>Modia3D.Composition.Object3D</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">obj1 = Object3D([data]; visualizeFrame=Modia3D.Inherited)
obj2 = Object3D(parent [, data]; fixed=true, r=zeros(3), R=nothing, q=nothing,
                v_start=zeros(3), w_start=zeros(3),
                visualizeFrame=Modia3D.Inherited)</code></pre><p>Generate a new Object3D object, that is a coordinate system (= frame) with associated data. If <code>parent</code> is present, the Object3D is defined relatively to the parent Object3D. If <code>parent</code> is not present, the Object3D is either a reference object (such as the world-object), or the object is connected later with a joint to another Object3D. If <code>fixed=true</code>, the object is rigidly connect to its parent; otherwise it is moving freely relative to its parent (mathematically described by quaternions).</p><p>Note, there are many convenience functions in ModiaMath.Frames to generate a ModiaMath.RotationMatrix <code>R</code> or a ModiaMath.Quaternion <code>q</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>data::Modia3D.AbstractObject3Ddata</code>: Optional data associated with Object3D.</p></li><li><p><code>parent::Object3D</code>: Parent object.</p></li><li><p><code>fixed::Bool</code>:</p><ul><li><code>fixed = true</code>, if the Object3D is fixed relatively to its parent Object3D at position <code>r,R,q</code>. It is best to provide the rotation information via <code>R</code> in this case.</li><li><code>fixed = false</code>, if Object3D can move freely relatively to its parent Object3D and is  initially placed at <code>r,R,q</code>. The movement is internally described with Quaternion vector <code>q</code>.  Therefore, it is best to provide the rotation information via <code>q</code> in this case.</li></ul></li><li><p><code>r::AbstractVector</code>: Initial relative position vector from frame of parent object to  origin of frame object, resolved in parent frame.</p></li><li><p><code>R::Union{ModiaMath.RotationMatrix,NOTHING}</code>: Initial rotation matrix defining the rotation  from frame of parent object to frame of Object3D. If both <code>R = nothing</code> and <code>q = nothing</code>,  a null rotation is defined.</p></li><li><p><code>q::Union{ModiaMath.Quaternion,NOTHING}</code>: Initial quaternion defining the rotation  from frame of parent object to frame of Object3D. If both <code>R = nothing</code> and <code>q = nothing</code>,  a null rotation is defined.</p></li><li><p><code>v_start::AbstractVector</code>: If <code>fixed=false</code>, initial velocity of the origin of Object3D with respect to parent, resolved in parent frame.</p></li><li><p><code>w_start::AbstractVector</code>: If <code>fixed=false</code>, initial angular velocity of Object3D with respect to parent, resolved in Object3D.</p></li><li><p><code>visualizeFrame::Union{Bool,Modia3D.Ternary}</code>: Coordinate system of Object3D is always (= true), or never (= false) visualized, or it is visualized if defined in SceneOptions(...) (= Modia3D.Inherited).</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">using Modia3D

# Define assembly
@assembly MyAssembly begin
   world = Object3D()

   # Frame fixed in world
   frame1 = Object3D(world; r=[0.1, 0.2, 0.3])

   # Frame moving relatively to frame1
   r2     = [0.2, 0.2, 0.3]
   frame2 = Object3D(frame1; fixed=false, r=r2)

   # Frame moving relatively to world
   frame3 = Object3D(world; fixed=false, r=-r2)
end
Modia3D.visualizeAssembly!(MyAssembly())</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.PointGravityField" href="#Modia3D.Composition.PointGravityField"><code>Modia3D.Composition.PointGravityField</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PointGravityField([mass|;mue=G*EarthMass])</code></pre><p>Return a PointGravityField struct with the gravity field constant mue (mue = G*mass).</p><p><strong>Example</strong></p><pre><code class="language-julia">import Modia3D

grav = Modia3D.PointGravityField()   # Gravity field of earth
   r = Modia3D.EarthRadius
   g = gravityAcceleration(grav,r)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.SceneOptions" href="#Modia3D.Composition.SceneOptions"><code>Modia3D.Composition.SceneOptions</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">sceneOptions = Modia3D.SceneOptions(;kwargs...)</code></pre><p>Define global options for a simulation of the scene with keyword arguments:</p><table><tr><th style="text-align: left">Keyword arguments</th><th style="text-align: left">defaults</th></tr><tr><td style="text-align: left">enableContactDetection</td><td style="text-align: left">true</td></tr><tr><td style="text-align: left">elasticContactReductionFactor</td><td style="text-align: left">1.0</td></tr><tr><td style="text-align: left">gravityField</td><td style="text-align: left"><a href="Composition.html#Modia3D.Composition.UniformGravityField"><code>Modia3D.UniformGravityField</code></a>()</td></tr><tr><td style="text-align: left">enableVisualization</td><td style="text-align: left">true</td></tr><tr><td style="text-align: left">visualizeGravity</td><td style="text-align: left">true</td></tr><tr><td style="text-align: left">visualizeFrames</td><td style="text-align: left">false</td></tr><tr><td style="text-align: left">visualizeConvexHulls</td><td style="text-align: left">true</td></tr><tr><td style="text-align: left">visualizeContactPoints</td><td style="text-align: left">false</td></tr><tr><td style="text-align: left">visualizeSupportPoints</td><td style="text-align: left">false</td></tr><tr><td style="text-align: left">nominalLength</td><td style="text-align: left">1.0</td></tr><tr><td style="text-align: left">defaultFrameLength</td><td style="text-align: left">0.2*nominalLength</td></tr><tr><td style="text-align: left">defaultJointLength</td><td style="text-align: left">nominalLength/10</td></tr><tr><td style="text-align: left">defaultJointWidth</td><td style="text-align: left">nominalLength/20</td></tr><tr><td style="text-align: left">defaultForceLength</td><td style="text-align: left">nominalLength/10</td></tr><tr><td style="text-align: left">defaultForceWidth</td><td style="text-align: left">nominalLength/20</td></tr><tr><td style="text-align: left">defaultBodyDiameter</td><td style="text-align: left">nominalLength/9</td></tr><tr><td style="text-align: left">defaultWidthFraction</td><td style="text-align: left">20</td></tr><tr><td style="text-align: left">defaultArrowDiameter</td><td style="text-align: left">nominalLength/40</td></tr><tr><td style="text-align: left"><code>defaultN_to_m</code></td><td style="text-align: left">1000</td></tr><tr><td style="text-align: left"><code>defaultNm_to_m</code></td><td style="text-align: left">1000</td></tr><tr><td style="text-align: left">useOptimizedStructure</td><td style="text-align: left">true</td></tr><tr><td style="text-align: left">defaultContactSphereDiameter</td><td style="text-align: left">0.1</td></tr><tr><td style="text-align: left">contactDetection</td><td style="text-align: left">ContactDetectionMPR_handler()</td></tr></table><p><strong>Optional keyword arguments</strong></p><ul><li><code>enableContactDetection::Bool</code>: = true, if contact detection is enabled</li><li><code>elasticContactReductionFactor::Float64</code>: used<em>contact</em>compliance = contact_compliance * elasticContactReductionFactor (&gt; 0).</li><li><code>gravityField::Modia3D.AbstractGravityField</code>: Type of gravity field, such as: <a href="Composition.html#Modia3D.Composition.NoGravityField"><code>Modia3D.NoGravityField</code></a>, <a href="Composition.html#Modia3D.Composition.UniformGravityField"><code>Modia3D.UniformGravityField</code></a>, <a href="Composition.html#Modia3D.Composition.PointGravityField"><code>Modia3D.PointGravityField</code></a>.</li><li><code>enableVisualization::Bool</code>: = true, if animation is enabled</li><li><code>visualizeGravity::Bool</code>: = true, if gravity field shall be visualized (acceleration vector or field center)</li><li><code>visualizeFrames::Bool</code>: = true, if all frames shall be visualized</li><li><code>visualizeConvexHulls::Bool</code>: = true, if convex hulls (used for contact detection) shall be visualized</li><li><code>visualizeContactPoints::Bool</code>: = true, if contact points shall be visualized</li><li><code>visualizeSupportPoints::Bool</code> = true, if support points shall be visualized</li><li><code>nominalLength::Float64</code>: [m] Nominal length of 3D system</li><li><code>defaultFrameLength::Float64</code>: [m] Default for frame length if visualizeFrames = true (but not world frame)</li><li><code>defaultJointLength::Float64</code>: [m] Default for the fixed length of a shape representing a joint</li><li><code>defaultJointWidth::Float64</code>:  [m] Default for the fixed width of a shape representing a joint</li><li><code>defaultForceLength::Float64</code>: [m] Default for the fixed length of a shape representing a force (e.g., damper)</li><li><code>defaultForceWidth::Float64</code>:  [m] Default for the fixed width of a shape representing a force (e.g., spring, bushing)</li><li><code>defaultBodyDiameter::Float64</code>: [m] Default for diameter of sphere representing the center of mass of a body</li><li><code>defaultWidthFraction::Float64</code>: Default for shape width as a fraction of shape length</li><li><code>defaultArrowDiameter::Float64</code>: [m] Default for arrow diameter (e.g., of forces, torques, sensors)</li><li><code>defaultN_to_m::Float64</code>: [N/m] Default scaling of force arrows (length = force/defaultN<em>to</em>m)</li><li><code>defaultNm_to_m::Float64</code>: [N.m/m] Default scaling of torque arrows (length = torque/defaultNm<em>to</em>m)</li><li><code>useOptimizedStructure::Bool</code>: = true, if the optimized structure (with super objects, and common inertia) is used</li><li><code>defaultContactSphereDiameter::Float64</code>: [m] Diameter of sphere used for contact point visualization</li><li><code>contactDetection::Modia3D.AbstractContactDetection</code>: Handler used for contact detection (for example to determine the smallest distance between two objects).</li></ul><p><strong>Example</strong></p><p>For all the details see &quot;Modia3D/examples/dynamics/Simulate_Pendulum.jl&quot;:</p><pre><code class="language-julia">
@assembly Pendulum(;Lx = 1.0) begin
   ...
end

pendulum = Pendulum(Lx=1.6, sceneOptions=
             Modia3D.SceneOptions(visualizeFrames=true, defaultFrameLength=0.3))
model    = Modia3D.SimulationModel( pendulum )
result   = ModiaMath.simulate!(model, stopTime=4.5)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.SimulationModel" href="#Modia3D.Composition.SimulationModel"><code>Modia3D.Composition.SimulationModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">simModel = SimulationModel(assembly::Modia3D.AbstractAssembly;
                           analysis::ModiaMath.AnalysisType=ModiaMath.DynamicAnalysis,
                           startTime = 0.0, stopTime  = 1.0, tolerance = 1e-4,
                           interval  = (stopTime-startTime)/500.0,
                           maxStepSize = NaN, maxNumberOfSteps=missing)</code></pre><p>Generate a <code>simulationModel</code> from an <code>assembly</code> generated with macro <a href="Composition.html#Modia3D.Composition.@assembly-Tuple{Any,Any}"><code>Modia3D.@assembly</code></a> and the type of <code>analysis</code> to be carried out on the <code>assembly</code>. Additionally, default <code>startTime</code>, <code>stopTime</code>, <code>tolerance</code>, <code>interval</code>, <code>maxStepSize</code>, <code>maxNumberOfSteps</code>, for the simulation engine are defined. These values should be adapted so that assembly-specific, meaningful defaults are provided.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.UniformGravityField" href="#Modia3D.Composition.UniformGravityField"><code>Modia3D.Composition.UniformGravityField</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">UniformGravityField(;g=9.81, n=[0,1,0])</code></pre><p>Return a UniformGravityField struct.</p><p><strong>Arguments</strong></p><ul><li><code>g::Float64</code>: Gravity constant</li><li><code>n::AbstractVector</code>: Direction of gravity</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">import Modia3D

grav = Modia3D.UniformGravityField()
   r = Modia3D.EarthRadius
   g = gravityAcceleration(grav,r)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.Fixed-Tuple{Object3D,Object3D}" href="#Modia3D.Composition.Fixed-Tuple{Object3D,Object3D}"><code>Modia3D.Composition.Fixed</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">joint = Modia3D.Fixed(obj1, obj2; r=zeros(3), R=nothing, q=nothing)</code></pre><p>Return a Fixed <code>joint</code> that fixes <code>obj2::</code><a href="Composition.html#Modia3D.Composition.Object3D"><code>Object3D</code></a> relatively to <code>obj1::</code><a href="Composition.html#Modia3D.Composition.Object3D"><code>Object3D</code></a> via the relative position vector from <code>obj1</code> to <code>obj2</code> (resolved in <code>obj1</code>) and the relative transformation matrix <code>R</code> from <code>obj1</code> to <code>obj2</code> or alternatively the relative quaternion <code>q</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>obj1::Object3D</code>: Parent object.</p></li><li><p><code>obj2::Object3D</code>: Object fixed relative to <code>obj1</code>.</p></li><li><p><code>r::AbstractVector</code>: Relative position vector from <code>obj1</code> to <code>obj2</code>  resolved in <code>obj1</code>.</p></li><li><p><code>R::Union{ModiaMath.RotationMatrix,Nothing}</code>: Rotation matrix defining the rotation  from <code>obj1</code> to <code>obj</code>. If both <code>R = nothing</code> and <code>q = nothing</code>,  a null rotation is defined.</p></li><li><p><code>q::Union{ModiaMath.Quaternion,Nothing}</code>: Quaternion defining the rotation  from <code>obj1</code> to <code>obj2</code>. If both <code>R = nothing</code> and <code>q = nothing</code>,  a null rotation is defined.</p></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.Prismatic-Tuple{Object3D,Object3D}" href="#Modia3D.Composition.Prismatic-Tuple{Object3D,Object3D}"><code>Modia3D.Composition.Prismatic</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">joint = Modia3D.Prismatic(obj1::Object3D, obj2::Object3D;
                          axis=1, s_start=0, v_start=0, canCollide=false)</code></pre><p>Return a <code>joint</code> object that constrains the movement of <code>obj2::</code><a href="Composition.html#Modia3D.Composition.Object3D"><code>Object3D</code></a> with respect to <code>obj1::</code><a href="Composition.html#Modia3D.Composition.Object3D"><code>Object3D</code></a> along coordinate axis <code>axis</code> (<code>axis = 1,2,3,-1,-2,-3</code>). The initial position/velocity of <code>obj2</code> with respect to <code>obj1</code> along <code>axis</code> is <code>s_start</code> [m] and <code>v_start</code> [m/s], respectively. If <code>canCollide=false</code>, no collision detection will occur between <code>obj1</code> and <code>obj2</code> (and <code>Object3D</code>s that are directly or indirectly rigidly fixed to <code>obj1</code> or <code>obj2</code>).</p><p>If a <code>Prismatic</code> joint <em>closes a kinematic loop</em>, then the already present objects must be consistent to the <code>Prismatic</code> joint that is the frames of <code>obj1</code> and <code>obj2</code> must be <em>parallel</em> to each other and movement of <code>obj1</code> along its axis <code>axis</code> with <code>s_start</code> results in <code>obj2</code>. If <code>s_start=NaN</code>, its value is computed in this case.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Modia3D
import ModiaMath

@assembly FallingBall(;h=1.0) begin
   world  = Object3D()
   sphere = Object3D( Modia3D.Solid(Modia3D.SolidSphere(0.1), &quot;Aluminium&quot;) )

   # Constrain sphere movement (initial placement at position [0,h,0])
   prismatic = Modia3D.Prismatic(world, sphere, axis=2, s_start=h)
end

simulationModel = Modia3D.SimulationModel( FallingBall(h=1.5), stopTime=1.0 )
result          = ModiaMath.simulate!(simulationModel)
ModiaMath.plot(result, (&quot;prismatic.s&quot;, &quot;prismatic.v&quot;))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.Revolute-Tuple{Object3D,Object3D}" href="#Modia3D.Composition.Revolute-Tuple{Object3D,Object3D}"><code>Modia3D.Composition.Revolute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">joint = Modia3D.Revolute(obj1, obj2; axis=3, phi_start=0, w_start=0, canCollide=false, J=NaN)</code></pre><p>Return a Revolute <code>joint</code> that rotates <code>obj1::</code><a href="Composition.html#Modia3D.Composition.Object3D"><code>Object3D</code></a> into <code>obj2::</code><a href="Composition.html#Modia3D.Composition.Object3D"><code>Object3D</code></a> along the axis <code>axis</code> of <code>obj1</code> (<code>axis = 1,2,3,-1,-2,-3</code>). The initial start angle is <code>phi_start</code> and the initial angular velocity is <code>w_start</code>. If <code>canCollide=false</code>, no collision detection will occur between <code>obj1</code> and <code>obj2</code> (and <code>Object3D</code>s that are directly or indirectly rigidly fixed to <code>obj1</code> or <code>obj2</code>).</p><p>Optionally, an inertia can be placed on the axis of rotation (<code>J</code>). If such an inertia is provided, the generalized coordinate is still the angle of the revolute joint and the driving torque is still the torque acting in the revolute joint. If, for example, an electric motor with a gearbox shall be modelled then</p><pre><code class="language-julia">J = JMotor*gearRatio^2
jointTorque = motorTorque*gearRatio
motor</code></pre><p>``<code>J = JMotor*gearRatio^2; jointTorque =</code>.</p><p>If a <code>Revolute</code> joint <em>closes a kinematic loop</em>, then the already present objects must be consistent to the <code>Revolute</code> joint. That is, the frames of <code>obj1</code> and <code>obj2</code> must be <em>parallel</em> to each other and rotating <code>obj1</code> along its axis <code>axis</code> with <code>phi_start</code> results in <code>obj2</code>. If <code>phi_start=NaN</code>, its value is computed in this case.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Modia3D
import ModiaMath

@assembly Pendulum(;L=1.0) begin
   world  = Modia3D.Object3D()
   obj1 = Modia3D.Object3D()
   rev    = Modia3D.Revolute(world, obj1)
   sphere = Modia3D.Object3D(obj1, Modia3D.Solid(Modia3D.SolidSphere(0.1), &quot;Aluminium&quot;),
                             r = [L,0,0] )
end

simulationModel = Modia3D.SimulationModel( Pendulum(L=0.8), stopTime=5.0 )
result          = ModiaMath.simulate!(simulationModel)
ModiaMath.plot(result, (&quot;rev.phi&quot;, &quot;rev.w&quot;))</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.contactStart-Tuple{Modia3D.Solids.ElasticContactPairMaterial,Object3D,Object3D,StaticArrays.SArray{Tuple{3},Float64,1,3},StaticArrays.SArray{Tuple{3},Float64,1,3},Float64}" href="#Modia3D.Composition.contactStart-Tuple{Modia3D.Solids.ElasticContactPairMaterial,Object3D,Object3D,StaticArrays.SArray{Tuple{3},Float64,1,3},StaticArrays.SArray{Tuple{3},Float64,1,3},Float64}"><code>Modia3D.Composition.contactStart</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>resonseMaterial = contactStart(matPair::Modia3D.ElasticContactPairMaterial,                                   obj1,obj2,rContact,contactNormal)</p><p>Return a <code>responseMaterial::ElasticContactPairResponseMaterial</code> object at the start of a collision.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.contactStart-Tuple{Object3D,Object3D,StaticArrays.SArray{Tuple{3},Float64,1,3},StaticArrays.SArray{Tuple{3},Float64,1,3},Float64}" href="#Modia3D.Composition.contactStart-Tuple{Object3D,Object3D,StaticArrays.SArray{Tuple{3},Float64,1,3},StaticArrays.SArray{Tuple{3},Float64,1,3},Float64}"><code>Modia3D.Composition.contactStart</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">responseMaterial = contactStart(obj1, obj2, rContact, contactNormal)</code></pre><p>Return a response material object at contact start.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.distance-Tuple{Object3D,Object3D}" href="#Modia3D.Composition.distance-Tuple{Object3D,Object3D}"><code>Modia3D.Composition.distance</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">d = distance(frame1, frame2)</code></pre><p>Return the distance between the origin of frame1 and the origin of frame2</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.normalRelativeVelocityAtContact-Tuple{Object3D,Object3D,StaticArrays.SArray{Tuple{3},Float64,1,3},StaticArrays.SArray{Tuple{3},Float64,1,3}}" href="#Modia3D.Composition.normalRelativeVelocityAtContact-Tuple{Object3D,Object3D,StaticArrays.SArray{Tuple{3},Float64,1,3},StaticArrays.SArray{Tuple{3},Float64,1,3}}"><code>Modia3D.Composition.normalRelativeVelocityAtContact</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">delta_dot = normalRelativeVelocityAtContact(obj1, obj2, rContact, contactNormal)</code></pre><p>Return the relative velocity in normal direction <code>contactNormal</code> at contact point <code>rContact</code> of the two penetrating objects <code>obj1, obj2</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.planarRotationAngle-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#Modia3D.Composition.planarRotationAngle-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>Modia3D.Composition.planarRotationAngle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">angle = planarRotationAngle(e, v1, v2)
      = planarRotationAngle(frame1, frame2)</code></pre><p>Return angle of a planar rotation, given the rotation axis e (a unit vector) and the representations of a vector in frame 1 (v1) and frame 2 (v2).</p><p>Under the assumption that the z-axes of frame1 and frame2 coincide, return the angle between the x-axis of frame1 and the position vector from frame1 to frame2.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.responseCalculation-Tuple{Modia3D.Composition.ElasticContactPairResponseMaterial,Object3D,Object3D,StaticArrays.SArray{Tuple{3},Float64,1,3},StaticArrays.SArray{Tuple{3},Float64,1,3},Float64,Float64,Any}" href="#Modia3D.Composition.responseCalculation-Tuple{Modia3D.Composition.ElasticContactPairResponseMaterial,Object3D,Object3D,StaticArrays.SArray{Tuple{3},Float64,1,3},StaticArrays.SArray{Tuple{3},Float64,1,3},Float64,Float64,Any}"><code>Modia3D.Composition.responseCalculation</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">(f1,f2,t1,t2) = responseCalculation(material::ElasticContactPairResponseMaterial,
                        obj1, obj2, rContact, contactNormal, distanceWithHysteresis, time)</code></pre><p>Compute contact forces <code>f1,f2</code> and contact torques <code>t1,t2</code> from the elastic contact pair response material <code>material</code> the two penetrating objects <code>obj1, obj2</code>, the contact point <code>rContact</code>, the contact normal <code>contactNormal</code> and the largest penetration depth <code>distanceWithHysteresis</code> at time <code>time</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.visualizeAssembly!-Tuple{Modia3D.AbstractAssembly}" href="#Modia3D.Composition.visualizeAssembly!-Tuple{Modia3D.AbstractAssembly}"><code>Modia3D.Composition.visualizeAssembly!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">visualizeAssembly!(assembly::Modia3D.AbstractAssembly)</code></pre><p>Visualize the <code>assembly</code> defined with macro <a href="Composition.html#Modia3D.Composition.@assembly-Tuple{Any,Any}"><code>Modia3D.@assembly</code></a> in its initial configuration (but without simulating it).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Modia3D.Composition.@assembly-Tuple{Any,Any}" href="#Modia3D.Composition.@assembly-Tuple{Any,Any}"><code>Modia3D.Composition.@assembly</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@assembly AssemblyName(arguments) begin ... end</code></pre><p>Return the constructor for a new struct <code>AssemblyName</code> consisting of Object3Ds that are connected together. The new struct consists of all left-hand-side (scalar or vector) symbols present between <code>begin ... end</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Modia3D

@assembly Bar(;Lx = 0.1, Ly=Lx/5, Lz=Ly) begin
   frame0 = Modia3D.Object3D(Modia3D.Solid(Modia3D.SolidBeam(Lx,Ly,Lz), nothing, vmat1))
   frame1 = Modia3D.Object3D(frame0; r=[-Lx/2, 0.0, 0.0])
   frame2 = Modia3D.Object3D(frame0; r=[ Lx/2, 0.0, 0.0])
   cyl1   = Modia3D.Object3D(frame1, cyl)
   cyl2   = Modia3D.Object3D(frame2, cyl)
end
bar = Bar(;Lx=1.0)
Modia3D.visualizeAssembly!( bar )</code></pre></div></div></section><footer><hr/><a class="previous" href="../man/Plans.html"><span class="direction">Previous</span><span class="title">Plans</span></a><a class="next" href="Graphics.html"><span class="direction">Next</span><span class="title">Graphics</span></a></footer></article></body></html>
