var documenterSearchIndex = {"docs":
[{"location":"index.html#Modia3D-1","page":"Home","title":"Modia3D","text":"","category":"section"},{"location":"index.html#Modia-Platform-1","page":"Home","title":"Modia Platform","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"The Modia platform is a prototype system for the next modeling and simulation generation of physical systems described by differential and algebraic equations. It consists currently of the following Julia packages that are all under development (not all are yet publicly available):","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Modia - Equation based modeling\nModiator - 2D/3D web-app model editor\nModiaMath - Simulation enviroment\nModia3D - 3D geometry and 3D mechanics\nModiaMedia - Thermodynamic property models\nModelia - Modelica model importer","category":"page"},{"location":"index.html#Modia3D-2","page":"Home","title":"Modia3D","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Modia3D provides 3D geometry to physical systems so that geometrical objects can be directly accessed and utilized in a model. Functions are provided, for example, to compute the volume, mass, and inertia of a geometrical object or the distance between two objects. Furthermore, Modia3D models 3D mechanical systems and shall be expanded into other domains in the future (for example to utilize the 3D geometry to model heat flow in buildings or satellites). In the future it will be possible, for example, to model the 3D mechanical part of a robot with Modia3D and the electrical motors and gearboxes that are driving the joints with Modia.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Modia3D uses ideas from modern computer game engines to achieve a highly flexible setup of mechanical systems including collision handling. Other features are utilized from multi-body programs, such as support for closed kinematic loops, and elastic response calculation. The underlying mathematical formulation are hybrid Differential Algebraic Equations (DAEs) that are solved with the variable-step solver IDA via the Sundials.jl Julia package.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Collision handling with elastic response calculation is performed for geometrical objects that are defined with a contact material and have a convex geometry or are approximated by the convex hull of a concave geometry. Penetration depths and Euclidean distances are computed with the improved Minkowski Portal Refinement (MPR) algorithm [1]. The details of the contact law are provided in [5] and several examples are discussed in [4]. The user's view of Modia3D is introduced in [2] showing the very flexible definition of 3D systems. Some key algorithms are discussed in [3]. A more detailed overview of the available features is also given in the Modia3D documentation.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Papers and videos about Modia3D:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"[1] Collision Handling with Variable-Step Integrators (EOOLT 2017, December)\n[2] Component-Based 3D Modeling of Dynamic Systems (American Modelica Conference 2018, October)\n[3] Algorithms for Component-Based 3D Modeling (13th International Modelica Conference 2019, March)\n[4] Modia3D: Modeling and Simulation of 3D-Systems in Julia (JuliaCon 2019, July, under review); talk recorded on YouTube\n[5] Collision Handling with Elastic Response Calculation and Zero-Crossing Functions (accepted for publication at (EOOLT 2019, November)","category":"page"},{"location":"index.html#Package-Features-1","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"A 3D object is an instance of struct Modia3D.Object3D and defines a coordinate system moving in 3D together with associated data and properties. The following Object3Ds are currently supported:","category":"page"},{"location":"index.html#Object3Ds-with-a-solid-part-1","page":"Home","title":"Object3Ds with a solid part","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Solid parts can be associated with a Modia3D.Object3D. They are defined with struct Modia3D.Solid consisting of an optional solid geometry:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"(Image: Solids)","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"and other optional properties:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"mass propreties (defined by geometry+material-name, geometry+density, or directly defined mass properties),\ncontact material (for elastic response calculation),\nvisualization material (for visualization, see below).","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Since the solid geometry itself is optional, it is possible to just define a coordinate system with associated mass and inertia matrix.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The following functions are provided for a solid geometry geo that is associated with an Object3D object3D:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"volume(geo),\ncentroid(geo),\ninertiaMatrix(geo, mass),\nboundingBox(geo, <other arguments>),\nsupportPoint(geo, <other arguments>),\nisVisible(object3D, renderer),\nhasMass(object3D),\ncanCollide(object3D),\nand other functions.","category":"page"},{"location":"index.html#Object3Ds-for-visualization-1","page":"Home","title":"Object3Ds for visualization","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Visualization elements that have a visualization material:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"(Image: VisuElements)","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"A visualiziation material has the following attributes:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"color (name or rgb-value),\nwireframe (false/true),\ntransparency (0.0 is opaque, 1.0 is fully transparent),\nreflectslight (false/true),\nshininess (0.0 is matte surface, 1.0 is very shiny),\nshadowMask (defines whether or not an object casts or receives shadows)","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Visualization elements that have no visualization material:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"(Image: Fonts)","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"It is planned to support all other visualization elements that are available in the DLR Visualization library (see videos of this library).","category":"page"},{"location":"index.html#Constraints-on-Object3Ds-1","page":"Home","title":"Constraints on Object3Ds","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"An Object3D can be either fixed or freely moving with respect to another Object3D. In the latter case, the movement is described by relative quaternions.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Furthermore, two Object3Ds can be connected together via various joint types. Currently, revolute and prismatic joints are supported. In the near future, more joint types will be added.","category":"page"},{"location":"index.html#Assemblies-of-Object3Ds-1","page":"Home","title":"Assemblies of Object3Ds","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Object3D definitions can be collected together with the Modia3D.@assembly macro in hierarchical structures. For example, in the following four bar mechanism (consisting of 3 bars and the ground as 4th bar), a bar is defined as an assembly consisting of a light-blue SolidBeam Object3D and two red Cylinder Object3Ds. Such a bar is then in turn assembled in the assembly FourBar shown below:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"(Image: fourbar)","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"There are the following operations on an instance of an assembly:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Modia3D.visualizeAssembly!(assembly) to visualize the initial configuration of the assembly without simulating anything.\nModia3D.SimulationModel(assembly; analysis=xxx, <other arguments>) to generate a simulationModel of the assembly that can be simulated with ModiaMath.simulate!. The analysis keyword defines which analysis shall be carried out on the model. Currently supported are KinematicAnalysis to kinematically move the assembly, or DynamicAnalysis to solve the equations of motion of the assembly. In the future it is planned to support QuasiStaticAnalysis as well.","category":"page"},{"location":"index.html#Release-Notes-1","page":"Home","title":"Release Notes","text":"","category":"section"},{"location":"index.html#Version-0.4.0-1","page":"Home","title":"Version 0.4.0","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Collision handling significantly improved:\nNew elastic response characteristics.\nContact start and end detection with zero crossing functions improved.\nMany bugs removed.\nSeveral examples for collision handling added.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"KUKA YouBot robot example added (together with simple PTP path planning).","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Documentation considerably improved.","category":"page"},{"location":"index.html#Version-0.3.0-1","page":"Home","title":"Version 0.3.0","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"The first version that requires Julia >= 1.0 (all Julia 0.6 and 0.7 code was removed).","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Adapted to ModiaMath 0.5.0 (earlier versions of ModiaMath are no longer supported).","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Prismatic and Revolute joints have a new keyword axis with possible values 1,2,3,-1,-2,-3, to define the axis of movement / rotation.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"All joints have a new keyword canCollide (default = false). If false, collision detection will not occur to the Object3Ds that are rigidly fixed to each other and connected by the joint.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Before a simulation is performed, the internal structure is optimized for the computation:\nFor all objects that are rigidly connected, the common mass, common center-of-mass, common inertia tensor are computed and used during simulation (and the source frames with mass property objects are ignored if not needed for other purposes).\nCollision detection is switched off for Object3D pairs that are rigidly connected to each other.\nThe spanning tree of the Object3Ds is simplified, so that during simulation only the minimum number of frames must be traversed and position, velocity, acceleration of these frames are computed. Object3Ds that are only used for visualization are only evaluated at communication points and only the position is computed (not velocity or acceleration).","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"More examples and tests added.","category":"page"},{"location":"index.html#Version-0.2.1-1","page":"Home","title":"Version 0.2.1","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Adapted to Julia 0.7 and 1.0 (including using new package manager via Project.toml, Manifest.toml files).","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Travis Continuous Integration added.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Wrong UUID of Modia3D and referenced ModiaMath corrected (did not correspond to the UUID in Julias METADATA).","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"PyPlot was removed from the REQUIRE and Project.toml files and code was added, so that PyPlot is automatically imported in ModiaMath if it is available in the current environment of the user. The benefit is that Modia3D and ModiaMath can be used, even if PyPlot is not installed. This is especially useful for ContinuousIntegration, because automatic installation of PyPlot often fails. Inspect the wiki page Installing PyPlot in a robust way to install PyPlot in a robust way.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"All extra packages used in examples and tests are now referenced via Modia3D (for example using Modia3D.StaticArrays instead of using StaticArrays). The benefit is that all examples and tests can be directly executed with include (for example: import Modia3D; include(Modia3D.path/examples/dynamics/Simulate_Pendulum.jl)) provided Modia3D is in the current environment. Previously, it was assumed that these extra packages are present in the users environment and an error occured, if this was not the case.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Dependent packages updated to their newest versions. Especially, warnings from Unitful do no longer occur, due to the update to version 0.12.0.","category":"page"},{"location":"index.html#Version-0.2.0-1","page":"Home","title":"Version 0.2.0","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"First public release (for Julia 0.6.4)","category":"page"},{"location":"index.html#Main-developers-1","page":"Home","title":"Main developers","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Andrea Neumayr and Martin Otter","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"DLR - Institute of System Dynamics and Control","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"License: MIT (expat)","category":"page"},{"location":"man/GettingStarted.html#Getting-Started-1","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"man/GettingStarted.html#Installation-1","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"man/GettingStarted.html#","page":"Getting Started","title":"Getting Started","text":"Modia3D is registered in METADATA.jl and can be installed in the following way (Julia >= 1.0 is required):","category":"page"},{"location":"man/GettingStarted.html#","page":"Getting Started","title":"Getting Started","text":"julia> ]add Modia3D\r\n        add ModiaMath  # in order to use simulate!(..) and plot(..)\r\n        add PyPlot     # in order that plots are shown","category":"page"},{"location":"man/GettingStarted.html#","page":"Getting Started","title":"Getting Started","text":"Modia3D uses PyPlot for plotting. If PyPlot is not available in your current Julia environment an information message is printed and all plot(..) calls are ignored.","category":"page"},{"location":"man/GettingStarted.html#","page":"Getting Started","title":"Getting Started","text":"In order that plot windows are displayed, you need to add PyPlot to your current environment via ]add PyPlot. Often this automatic installation fails and it is recommended to follow the instructions Installing PyPlot in a robust way.","category":"page"},{"location":"man/GettingStarted.html#","page":"Getting Started","title":"Getting Started","text":"Modia3D visualizes the movement of 3D objects with a renderer. Currently, the (free) community or the (commercial) professional version of the DLR Visualization library are supported. To install the free version for Windows or for Linux perform the following steps:","category":"page"},{"location":"man/GettingStarted.html#","page":"Getting Started","title":"Getting Started","text":"Go to https://visualization.ltx.de/, provide your contact information and click on Request download for Community Edition. Afterwards, you get a link to download the library and you need to unzip the file.","category":"page"},{"location":"man/GettingStarted.html#","page":"Getting Started","title":"Getting Started","text":"In your Julia startup file (HOME/.julia/config/startup.jl), include the environment variable ENV[\"DLR_VISUALIZATION\"] = \"<path-to-library>/Visualization/Extras/SimVis\". Make sure that the SimVis executable under this directory has execution rights. For example in Linux with command: chmod +x <path-to-library>/Visualization/Extras/SimVis","category":"page"},{"location":"man/GettingStarted.html#","page":"Getting Started","title":"Getting Started","text":"Start Julia and run one of the examples, for example include(\"$(Modia3D.path)/examples/dynamics/Simulate_DoublePendulumWithDampers.jl\")","category":"page"},{"location":"man/GettingStarted.html#","page":"Getting Started","title":"Getting Started","text":"If Modia3D cannot use one of the renderers above, it will continue with renderer NoRenderer that is animation is switched off.","category":"page"},{"location":"man/GettingStarted.html#To-run-examples-1","page":"Getting Started","title":"To run examples","text":"","category":"section"},{"location":"man/GettingStarted.html#","page":"Getting Started","title":"Getting Started","text":"  import Modia3D\r\n  include(\"$(Modia3D.path)/examples/dynamics/Simulate_DoublePendulumWithDampers.jl\")\r\n  include(\"$(Modia3D.path)/examples/dynamics/Simulate_FallingBall4.jl\")\r\n  include(\"$(Modia3D.path)/examples/kinematics/Move_FourBar.jl\")\r\n  include(\"$(Modia3D.path)/examples/visual/Move_AllVisualObjects.jl\")","category":"page"},{"location":"man/GettingStarted.html#To-run-tests-1","page":"Getting Started","title":"To run tests","text":"","category":"section"},{"location":"man/GettingStarted.html#","page":"Getting Started","title":"Getting Started","text":"  import Modia3D\r\n  include(\"$(Modia3D.path)/test/runtests.jl\")","category":"page"},{"location":"man/Examples.html#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"man/Examples.html#","page":"Examples","title":"Examples","text":"Modia3D has examples in directory","category":"page"},{"location":"man/Examples.html#","page":"Examples","title":"Examples","text":"$(Modia3D.path)/examples","category":"page"},{"location":"man/Examples.html#","page":"Examples","title":"Examples","text":"to demonstrate various features of the package. Every example is in a separate module. Most important examples (by pasting the corresponding include(..) command in the REPL, the example is executed):","category":"page"},{"location":"man/Examples.html#","page":"Examples","title":"Examples","text":"  import Modia3D\r\n\r\n  # Examples to demonstrate the visualization capabilities of Modia3D\r\n  include(\"$(Modia3D.path)/examples/visual/Visualize_Solids.jl\")\r\n  include(\"$(Modia3D.path)/examples/visual/Visualize_GeometriesWithMaterial.jl\")\r\n  include(\"$(Modia3D.path)/examples/visual/Visualize_GeometriesWithoutMaterial.jl\")\r\n  include(\"$(Modia3D.path)/examples/visual/Visualize_Text.jl\")\r\n  include(\"$(Modia3D.path)/examples/visual/Visualize_TextFonts.jl\")\r\n  include(\"$(Modia3D.path)/examples/visual/Move_AllVisualObjects.jl\")\r\n\r\n  # Examples to demonstrate kinematic movement of assemblies\r\n  include(\"$(Modia3D.path)/examples/kinematics/Move_DoublePendulum.jl\")\r\n  include(\"$(Modia3D.path)/examples/kinematics/Move_FourBar.jl\")\r\n  include(\"$(Modia3D.path)/examples/kinematics/Move_FourBar2.jl\")\r\n\r\n  # Examples to demonstrate dynamic simulation without force elements\r\n  include(\"$(Modia3D.path)/examples/dynamics/Simulate_Pendulum.jl\")\r\n  include(\"$(Modia3D.path)/examples/dynamics/Simulate_DoublePendulum.jl\")\r\n\r\n  # Examples to demonstrate dynamic simulation with force elements connected to joints\r\n  include(\"$(Modia3D.path)/examples/dynamics/Simulate_PendulumWithDamper.jl\")\r\n  include(\"$(Modia3D.path)/examples/dynamics/Simulate_PendulumWithController.jl\")\r\n  include(\"$(Modia3D.path)/examples/dynamics/Simulate_DoublePendulumWithDampers.jl\")\r\n\r\n  # Examples to demonstrate dynamic simulation with collision handling\r\n  include(\"$(Modia3D.path)/examples/dynamics/Simulate_FallingBall2.jl\")\r\n  include(\"$(Modia3D.path)/examples/dynamics/Simulate_FallingBall4.jl\")","category":"page"},{"location":"man/Materials.html#","page":"Materials","title":"Materials","text":"﻿","category":"page"},{"location":"man/Materials.html#Materials-1","page":"Materials","title":"Materials","text":"","category":"section"},{"location":"man/Materials.html#","page":"Materials","title":"Materials","text":"Modia3D uses various materials for different kind of purposes. In this section an overview of the material data and material palettes is given, as well as links to more detailed information. The following materia data is supported","category":"page"},{"location":"man/Materials.html#","page":"Materials","title":"Materials","text":"Color material: Color names and associated RGB values.","category":"page"},{"location":"man/Materials.html#","page":"Materials","title":"Materials","text":"Visual material: Visualization properties of a geometrical object, such as color or transparency.","category":"page"},{"location":"man/Materials.html#","page":"Materials","title":"Materials","text":"Solid material: Material constants of one solid, such as density or Young's modulus.","category":"page"},{"location":"man/Materials.html#","page":"Materials","title":"Materials","text":"Contact pair material: Material constants that are related to two solids that are in contact to each other, such as the coefficient of restitution between a Steel and an Aluminium object.","category":"page"},{"location":"man/Materials.html#Color-material-1","page":"Materials","title":"Color material","text":"","category":"section"},{"location":"man/Materials.html#","page":"Materials","title":"Materials","text":"Color can be defined by a name, such as Red, and this  name is associated with an Int-vector where the entries correspond to RGB values.  Default color definitions are available via the Modia3D.colorPalette  dictionary, where the color name is used as key and which is filled during the first  usage of Modia3D from file Modia3D/palettes/colors.json.","category":"page"},{"location":"man/Materials.html#Content-of-colors-palette-1","page":"Materials","title":"Content of colors palette","text":"","category":"section"},{"location":"man/Materials.html#","page":"Materials","title":"Materials","text":"import Modia3D\r\nsort(Modia3D.colorPalette)\r\nred_rgb = Modia3D.colorPalette[\"Red\"]","category":"page"},{"location":"man/Materials.html#Visual-material-1","page":"Materials","title":"Visual material","text":"","category":"section"},{"location":"man/Materials.html#","page":"Materials","title":"Materials","text":"The mutable struct Modia3D.Material defines various visual properties of a geometrical object, such as color or transparency. This data is used for visualization. Currently, there is no dictionary provided.","category":"page"},{"location":"man/Materials.html#Solid-material-1","page":"Materials","title":"Solid material","text":"","category":"section"},{"location":"man/Materials.html#","page":"Materials","title":"Materials","text":"The dictionary Modia3D.solidMaterialPalette provides material constants of one solid. The key is the material name as a string, and the value is an instance of the mutable struct Modia3D.SolidMaterial. This data is used, for example, to compute mass and inertia of an object (with density and the object geometry), or to compute the spring constant for a compliant contact (with Youngs's modulus and Poisson's ratio). It is filled during the first usage of Modia3D from file Modia3D/palettes/solidMaterials.json.","category":"page"},{"location":"man/Materials.html#Content-of-solid-material-palette-1","page":"Materials","title":"Content of solid material palette","text":"","category":"section"},{"location":"man/Materials.html#","page":"Materials","title":"Materials","text":"import Modia3D\r\nModia3D.listKeys(Modia3D.solidMaterialPalette)","category":"page"},{"location":"man/Materials.html#Contact-pair-material-1","page":"Materials","title":"Contact pair material","text":"","category":"section"},{"location":"man/Materials.html#","page":"Materials","title":"Materials","text":"The dictionary Modia3D.contactPairMaterialPalette provides material constants that are related to two solids that are in contact to each other, for example the coefficient of restitution  between a \"Steel\" and an \"Aluminium\" object. It is filled during the first usage of Modia3D from file Modia3D/palettes/contactPairMaterials.json.","category":"page"},{"location":"man/Materials.html#Content-of-contact-pairs-palette-1","page":"Materials","title":"Content of contact pairs palette","text":"","category":"section"},{"location":"man/Materials.html#","page":"Materials","title":"Materials","text":"import Modia3D\r\nModia3D.listKeys(Modia3D.contactPairMaterialPalette)","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"﻿","category":"page"},{"location":"man/CollisionHandling.html#Collision-Handling-1","page":"Collision Handling","title":"Collision Handling","text":"","category":"section"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"Modia3D supports collisions of objects that are defined with a contact material and (a) have a convex geometry, or (b) can be approximated by a set of convex geometries, or (c) have a concave geometry that is (automatically) approximated by its convex hull. When contact occurs, the response is computed with elastic (nonlinear) force/torque laws based on the penetration depth and the relative motion of the objects in contact. It is planned to optionally also support impulsive response calculation in the future.","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"The current approach has several limitations that a user must know, in order that a simulation is successful:","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"The current collision handling is designed for variable step-size integrators for systems that have realistic physical material behaviour.","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"Usually, a relative tolerance of 10^-8 or smaller has to be used since otherwise a variable step-size integrator will typically fail. The reason is that the penetration depth is computed from the difference of tolerance-controlled variables and the precision will be not sufficient if a higher tolerance will be used because the penetration depth of hard contact materials is in the order of 10^-5  10^-6 m. A relative tolerancie of 10^-5 might be used, if the heuristic elastic contact reduction factor  is set to k_red = 10^-4 (see Material constants below).","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"A reasonable reliable simulation requires that objects have only point contact, since otherwise the contact point can easily jump between model evaluations and a variable step-size integrator will not be able to cope with this, so will terminate with an error. For this reason, all geometrical objects are slightly modified in various ways for the collision handling. Most important, all geometries are smoothed with a small sphere (e.g. with radius = 1mm) that is moved over all surfaces.","category":"page"},{"location":"man/CollisionHandling.html#Material-constants-1","page":"Collision Handling","title":"Material constants","text":"","category":"section"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"The response calculation uses the following material constants from the Solid material palette and from the Contact pair material palette.","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"E in [N/m^2]: Young's modulus of contact material (gt 0).\nnu: Poisson's ratio of contact material (0 lt nu lt 1).\ncor: Coefficient of restitution between two objects (0 le cor le 1).\nmu_k: Kinetic/sliding friction force coefficient between two objects (ge 0).\nmu_r: Rotational rolling resistance torque coefficient between two objects (ge 0).","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"Additionally, the response calculation is changed at small relative velocities and relative angular velocities. This region is defined by the following constants:","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"vsmall in [m/s]: Used for regularization when computing the unit vector in direction of                    the relative tangential velocity (see below).\nwsmall in [rad/s]: Used for regularization when computing the unit vector in direction of                      the relative angular velocity (see below).","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"Finally, the heuristic factor k_red (default = 1.0) can be defined with keyword argument elasticContactReductionFactor in the Modia3D.SceneOptions constructor. The goal is the following: Applying the elastic response calculation on hard materials such as steel, typically results in penetration depths in the order of 10^-5  10^-6 m. A penetration depth is implicitly computed by the difference of the absolute positions of the objects in contact and these absolute positions are typically error-controlled variables of the integrator. This in turn means that typically at least a relative tolerance of 10^-8 needs to be used for the integration, in order that the penetration depth is computed with 2 or 3 significant digits. To improve simulation speed, factor k_red reduces the stiffness of the contact and therefore enlarges the penetration depth. If k_red is for example set to 10^-4, the penetration depth might be in the order of 10^-3 m and then a relative tolerance of 10^-5 might be sufficient. In many cases, the essential response characteristic is not changed (just the penetration depth is larger), but simulation speed is significantly improved.","category":"page"},{"location":"man/CollisionHandling.html#Response-calculation-1","page":"Collision Handling","title":"Response calculation","text":"","category":"section"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"When two 3D objects penetrate each other with a penetration depth delta  0 then a contact force and a contact torque is computed from the elastic contact materials of the two objects in the following way (the contact force law in normal direction is based on [1], [3], the remaining force law on [2] with some extensions and corrections):","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"beginalign\r\nf_n        = k_red maxleft(0 c_res cdot c_geo cdot delta^n_geo cdot (1 + d cdot dotdelta) right) \r\nvecf_n = f_n cdot vece_n \r\nvecf_t = -mu_k cdot f_n cdot vece_treg \r\nvectau = -mu_r cdot mu_rgeo  cdot f_n cdot vece_omegareg\r\nendalign","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"where","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"vece_n: Unit vector perpendicular to the surface of object 1 at the contact point, pointing outwards.\nvece_treg: Regularized unit vector in direction of the tangential relative velocity (see below).\nvece_omegareg: Regularized unit vector in direction of the relative angular velocity (see below).\nf_n: Value of normal contact force in direction of vece_n acting on object 2 (f_n ge 0).\nvecf_n: Vector of normal contact force acting on object 2.\nvecf_t: Vector of sliding friction force acting on object 2 in opposite direction of the movement                 in the tangential plane of the contact.\nvectau: Vector of rolling resistance torque acting on object 2, in opposite direction to the                   relative angular velocity between the two contacting objects.\ndelta: Signed distance between object 1 and 2 in normal direction vece_n.              delta  0 if objects are penetrating each other.\ndotdelta: Signed relative velocity between object 1 and 2 in normal direction vece_n.\nc_res: Resultant elastic material constant in normal direction. This constant is computed        from the constants c_1 c_2 of the two contacting objects 1 and 2 as        c_res = 1left( 1c_1 + 1c_2 right). c_i is computed from the material properties as        c_i = E_i(1 - nu_i^2) where E_i is Young's modules and        nu_i is Poisson's ratio of object i.\nc_geo: Factor in f_n that is determined from the geometries of the              two objects (see below).\nn_geo: Exponent in f_n that is determined from the geometries of the              two objects (see below).\nd(cor_regdotdelta^-): Damping coefficient in normal direction as a function of        cor_reg and dotdelta^- (see below).\ncor_reg: Regularized coefficient of restitution between objects 1 and 2, see below.\ndotdelta^-: Value of dotdelta when contact starts (dotdelta^- ge 0).\nmu_k: Kinetic/sliding friction force coefficient between objects 1 and 2.\nmu_r: Rotational rolling resistance torque coefficient between objects 1 and 2.\nmu_rgeo: Factor in vectau that is determined from the geometries of the                   two objects (see below).\nk_red: Elastic contact reduction factor.","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"The max() operator in equation (1) is provided, in order to guarantee that f_n is always a compressive and never a pulling force because this would be unphysical.","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"In special cases (for example sphere rolling on a plane), the rotational coefficient of friction mu_rres can be interpreted as rolling resistance coefficient.","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"Coefficients c_geo n_geo mu_rgeo depend on the geometries of the objects that are in contact. Only for spheres meaning values are provided based on Hertz' pressure, because currently the collision handling in Modia3D does no provide enough information for other geometries (r_i is the radius of sphere i):","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"Object 1 Object 2 c_geo n_geo mu_rgeo\nSphere Sphere frac43 sqrt1(1r_1+1r_2) 15 1(1r_1+1r_2)\nSphere no Sphere frac43 sqrtr_1 15 r_1\nno Sphere no Sphere 1 10 10","category":"page"},{"location":"man/CollisionHandling.html#Regularized-unit-vectors-1","page":"Collision Handling","title":"Regularized unit vectors","text":"","category":"section"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"The unit vectors vece_t vece_omega are undefined if the relative velocity and/or the relative angular velocity vanish. They are therefore approximately calculated using utility function reg(v_abs v_small). This function returns v_abs if v_abs ge v_small and otherwise returns a third order polynomial with a minimum of v_small3 at v_abs=0 and smooth first and second derivatives at v_abs = v_small):","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"reg(v_abs v_small) = textif v_abs ge v_small textthen v_abs textelse\r\n                          fracv_abs^2v_small\r\n                          left( 1 - fracv_abs3v_small right) + fracv_small3","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"Example for v_small = 01:","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"(Image: Regularization function)","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"With vecv_i the absolute velocity of the contact point of object i, and vecomega_i the absolute angular velocity of object i, the regularized unit vectors are calculated with function reg() in the following way:","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"beginalign\r\nvece_treg       = fracvecv_reltreg(vecv_relt v_small) quad\r\n                          vecv_rel = vecv_2 - vecv_1 \r\n                          vecv_relt = vecv_rel  - (vecv_rel cdot vece_n) vece_n \r\nvece_omegareg = fracvecomega_relreg(vecomega_relomega_small) quad\r\n                          vecomega_rel = vecomega_2 - vecomega_1\r\nendalign","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"The effect is that the absolute value of a regularized unit vector is approximated by the following smooth characteristics (and therefore the corresponding friction force and contact torque have a similar characteristic)","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"(Image: Sliding friction force)","category":"page"},{"location":"man/CollisionHandling.html#Damping-coefficient-1","page":"Collision Handling","title":"Damping coefficient","text":"","category":"section"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"There are several proposal to compute the damping coefficient as a function of the coefficient of restitution cor and the velocity when contact starts dotdelta^-. For a comparision of the different formulations see [1], [3].","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"Whenever the coefficient of restitution cor  0, then an object 2 jumping on an object 1 will mathematically never come to rest, although this is unphysical. To fix this, the value of a coefficient of restitution is reduced when the velocity at contact start becomes small. Furthermore, the coefficient of restitution is restricted to not become smaller as a minimum value cor_min = 0001 in order to avoid a division by zero when computing the damping coefficient. The following regularization function is used:","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"cor_reg = cor_lim + (cor_min - cor_lim) cdot e^log(001) dotdelta^-v_small \r\n            cor_lim = max(cor_min cor)","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"Examples of this characteristics are shown in the next figure:","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"(Image: Regularized coefficient of restitution)","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"The damping coefficient d is basically computed with the formulation from [1] because a response calculation with impulses gives similar results for some experiments as shown in [3]. However, (a) instead of the coefficient of restitution, the regularized form from above is used, (b) dotdelta^- is regularized to avoid a division by zero, and (c) the damping coefficient is limited to d_max = 1000 to avoid an unphysical strong creeping effect for collisions with small cor_reg values:","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"d(cor_regdotdelta^-) = min(1000 frac8(1-cor_reg)left(5 cdot cor_reg cdot reg(dotdelta^- v_small) right))","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"Examples of this characteristics are shown in the next two figures:","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"(Image: Damping coefficient 1)","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"(Image: Damping coefficient 2)","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"In the next figure the simulation of a bouncing ball is shown where the response calculation is performed (a) with an impulse and (b) with the compliant force law above. In both cases the regularized coefficient of restitution cor_reg is going to zero when dotdelta^- becomes small. As can be seen, both formulations lead to similar responses:","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"(Image: Bouncing ball)","category":"page"},{"location":"man/CollisionHandling.html#Literature-1","page":"Collision Handling","title":"Literature","text":"","category":"section"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"[1]: Paulo Flores, Margarida Machado, Miguel Silva, Jorge Martins (2011):   On the continuous contact force models for soft materials in   multibody dynamics.   Multibody System Dynamics, Springer Verlag,   Vol. 25, pp. 357-375. 10.1007/s11044-010-9237-4.","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"[2]: Martin Otter, Hilding Elmqvist, José Díaz López (2005):   Collision Handling for the Modelica MultiBody Library.   Proceedings of the 4th International Modelica Conference 2005,   Gerhard Schmitz (Ed.), pages 45-53.","category":"page"},{"location":"man/CollisionHandling.html#","page":"Collision Handling","title":"Collision Handling","text":"[3]: Luka Skrinjar, Janko Slavic, Miha Boltezar (2018):   A review of continuous contact-force models in multibody dynamics.   International Journal of Mechanical Sciences, Volume 145,   Sept., pages 171-187.","category":"page"},{"location":"man/Plans.html#Plans-1","page":"Plans","title":"Plans","text":"","category":"section"},{"location":"man/Plans.html#Plans-for-version-1.0-1","page":"Plans","title":"Plans for version 1.0","text":"","category":"section"},{"location":"man/Plans.html#","page":"Plans","title":"Plans","text":"Modia3D is not yet ready and should not be used for production work. The features below are planned to be implemented before Modia3D version 1.0. We are very interested that other people help and contribute to Modia3D. If you would like to implement one of the features below (or any other features), please contact Martin.Otter@dlr.de.","category":"page"},{"location":"man/Plans.html#","page":"Plans","title":"Plans","text":"Features planned for version 1.0:","category":"page"},{"location":"man/Plans.html#","page":"Plans","title":"Plans","text":"General\nImproving efficiency: Debugging Modia3D with respect to unnecessary heap allocations during integration (especially, changing some of the remaining MVector{3,Float64} to SVector{3,Float64}).\nImproved documentation.","category":"page"},{"location":"man/Plans.html#","page":"Plans","title":"Plans","text":"ContactDetectionMPR\nThe MPR algorithm for distance computation needs to be more thoroughly tested.","category":"page"},{"location":"man/Plans.html#","page":"Plans","title":"Plans","text":"Solids\nMaking contact handling more robust and more thoroughly testing the contact response calculation.\nDefinition of meshes directly in Julia (not only via *.obj files).\nMap all non-triangles of *.obj files to triangles, in order that further operations (like volume computation) can operate on them.","category":"page"},{"location":"man/Plans.html#","page":"Plans","title":"Plans","text":"Renderer\nInterfacing the remaining features of the DLR Visualization library to Modia3D/Julia (cameras and paths, flexible surface, elastically deformed mesh, fluid flow visualization, head.up displays, effects, large terrains, ...).","category":"page"},{"location":"man/Plans.html#","page":"Plans","title":"Plans","text":"Composition\nVisualizing (optionally) the direction of the gravity vector if a parallel gravity field is used.\nSupport of more joint types (Spherical, Cylindrical, Planar, GearConstraint, ...).\nSupport of 3D force/torque objects.\nAutomatic handling of 2D and 3D kinematic loops for kinematic and dynamic analysis (currently only 2D kinematic loops are supported for kinematic analysis).\nSupport of analytic loop handling (along the line of the Assembly joints of the Modelica Standard Library, but fully automatic).\nUsing Modia components with input/output ports as signal generators or as force elements in Modia3D.\nUsing a Modia3D model as component in Modia.\nOptionally supporting an O(n) algorithm for the spanning tree.\nFor models that can be completely mapped to an ODE (= tree-structure with O(n) algorithm and all kinematic loops can be solved with the analytic loop handling), optionally an ODE integrator of DifferentialEquations.jl can be used for simulation.\nSupport for 1-dimensional heat transfer data attached to an Object3D (to make sure that further extensions of the concept in non-mechanical domains are possible).","category":"page"},{"location":"man/Plans.html#Plans-after-version-1.0-1","page":"Plans","title":"Plans after version 1.0","text":"","category":"section"},{"location":"man/Plans.html#","page":"Plans","title":"Plans","text":"The following features are planed after version 1.0 (especially together with interested collaborators):","category":"page"},{"location":"man/Plans.html#","page":"Plans","title":"Plans","text":"Solids\nSupport of operations on meshes with triangles to construct new meshes (extrusion, CSG) along the paper Generic Modelica Framework for MultiBody Contacts and Discrete Element Method.","category":"page"},{"location":"man/Plans.html#","page":"Plans","title":"Plans","text":"GUI\nSupport of an open source, web-browser-based GUI to graphically define 3D assemblies and use the GUI also as default renderer (along the paper 3D Schematics of Modelica Models and Gamification; probably using three.js as underlying web-browser, webgml based rendering engine).","category":"page"},{"location":"man/Plans.html#","page":"Plans","title":"Plans","text":"Composition\nSupport for hard contacts with impulses.\nAttaching other domains to Object3Ds (heat transfer, fluid flow, ...).","category":"page"},{"location":"lib/Composition.html#Composition-1","page":"Composition","title":"Composition","text":"","category":"section"},{"location":"lib/Composition.html#","page":"Composition","title":"Composition","text":"Modules = [Modia3D.Composition]\r\nPrivate = false","category":"page"},{"location":"lib/Composition.html#Modia3D.Composition","page":"Composition","title":"Modia3D.Composition","text":"module Modia3D.Composition\n\nStructuring of objects moving in 3D. Most important constructors (dof are the degrees-of-freedom):\n\nFunction dof Description\n@assemblyName(..) begin .. end - Return a Name constructor for Object3Ds\nObject3D([data];..) 0 Return a reference Object3D\nObject3D(parent [, data];..) 0,6 Return Object3D fixed/moving w.r.t. parent\nModia3D.Revolute(obj1,obj2;..) 1 Return a revolute joint\nModia3D.Prismatic(obj1,obj2;..) 1 Return a prismatic joint\n\nThe optional data associated with an Object3D can be one of the following:\n\ndata Description\n::Modia3D.Solid Solids with geometry, mass, visual/contact material\n<:Modia3D.AbstractVisualElement Visual elements (Modia3D.Graphics)\n\nMain developers\n\nAndrea Neumayr and Martin Otter, DLR - Institute of System Dynamics and Control\n\n\n\n\n\n","category":"module"},{"location":"lib/Composition.html#Modia3D.Composition.ContactDetectionMPR_handler","page":"Composition","title":"Modia3D.Composition.ContactDetectionMPR_handler","text":"handler = ContactDetectionMPR_handler(;tol_rel = 1e-4, niter_max=100, neps=sqrt(eps()))\n\nGenerate a new contact handler for usage of the MPR algorithm The handler instance contains all information about the contact situation.\n\nArguments\n\ntol_rel: Relative tolerance to compute the contact point (> 0.0)\nniter_max: Maximum number of iterations of the MPR algorithm. If this number is reached,              an error occurs (> 0).\nneps: Small number used to check whether a floating number is close to zero (> 0.0).\n\n\n\n\n\n","category":"type"},{"location":"lib/Composition.html#Modia3D.Composition.ContactPair","page":"Composition","title":"Modia3D.Composition.ContactPair","text":"pair = ContactPair(contactPoint1,contactPoint2,contactNormal,obj1,obj2,\n                   distanceWithHysteresis)\n\nGenerate a new ContactPair object of two objects that have contact=true.\n\n\n\n\n\n","category":"type"},{"location":"lib/Composition.html#Modia3D.Composition.ElasticContactPairResponseMaterial","page":"Composition","title":"Modia3D.Composition.ElasticContactPairResponseMaterial","text":"m = ElasticContactPairResponseMaterial(c_res, d_res, mu_k, mu_r, vsmall, wsmall)\n\nReturn an ElasticContactPairResponseMaterial < AbstractContactPairMaterial object.\n\n\n\n\n\n","category":"type"},{"location":"lib/Composition.html#Modia3D.Composition.NoContactPair","page":"Composition","title":"Modia3D.Composition.NoContactPair","text":"pair = NoContactPair(contactPoint1,contactPoint2,contactNormal,obj1,obj2,\n                     distanceWithHysteresis)\n\nGenerate a new NoContactPair object of two objects that have contact=false.\n\n\n\n\n\n","category":"type"},{"location":"lib/Composition.html#Modia3D.Composition.NoGravityField","page":"Composition","title":"Modia3D.Composition.NoGravityField","text":"gravityField = NoGravityField()\n\nGenerate an instance of type NoGravityField that defines no gravity.\n\n\n\n\n\n","category":"type"},{"location":"lib/Composition.html#Modia3D.Composition.Object3D","page":"Composition","title":"Modia3D.Composition.Object3D","text":"obj1 = Object3D([data]; visualizeFrame=Modia3D.Inherited)\nobj2 = Object3D(parent [, data]; fixed=true, r=zeros(3), R=nothing, q=nothing,\n                v_start=zeros(3), w_start=zeros(3),\n                visualizeFrame=Modia3D.Inherited)\n\nGenerate a new Object3D object, that is a coordinate system (= frame) with associated data. If parent is present, the Object3D is defined relatively to the parent Object3D. If parent is not present, the Object3D is either a reference object (such as the world-object), or the object is connected later with a joint to another Object3D. If fixed=true, the object is rigidly connect to its parent; otherwise it is moving freely relative to its parent (mathematically described by quaternions).\n\nNote, there are many convenience functions in ModiaMath.Frames to generate a ModiaMath.RotationMatrix R or a ModiaMath.Quaternion q.\n\nArguments\n\ndata::Modia3D.AbstractObject3Ddata: Optional data associated with Object3D.\nparent::Object3D: Parent object.\nfixed::Bool:\nfixed = true, if the Object3D is fixed relatively to its parent Object3D at position r,R,q. It is best to provide the rotation information via R in this case.\nfixed = false, if Object3D can move freely relatively to its parent Object3D and is  initially placed at r,R,q. The movement is internally described with Quaternion vector q.  Therefore, it is best to provide the rotation information via q in this case.\nr::AbstractVector: Initial relative position vector from frame of parent object to  origin of frame object, resolved in parent frame.\nR::Union{ModiaMath.RotationMatrix,NOTHING}: Initial rotation matrix defining the rotation  from frame of parent object to frame of Object3D. If both R = nothing and q = nothing,  a null rotation is defined.\nq::Union{ModiaMath.Quaternion,NOTHING}: Initial quaternion defining the rotation  from frame of parent object to frame of Object3D. If both R = nothing and q = nothing,  a null rotation is defined.\nv_start::AbstractVector: If fixed=false, initial velocity of the origin of Object3D with respect to parent, resolved in parent frame.\nw_start::AbstractVector: If fixed=false, initial angular velocity of Object3D with respect to parent, resolved in Object3D.\nvisualizeFrame::Union{Bool,Modia3D.Ternary}: Coordinate system of Object3D is always (= true), or never (= false) visualized, or it is visualized if defined in SceneOptions(...) (= Modia3D.Inherited).\n\nExamples\n\nusing Modia3D\n\n# Define assembly\n@assembly MyAssembly begin\n   world = Object3D()\n\n   # Frame fixed in world\n   frame1 = Object3D(world; r=[0.1, 0.2, 0.3])\n\n   # Frame moving relatively to frame1\n   r2     = [0.2, 0.2, 0.3]\n   frame2 = Object3D(frame1; fixed=false, r=r2)\n\n   # Frame moving relatively to world\n   frame3 = Object3D(world; fixed=false, r=-r2)\nend\nModia3D.visualizeAssembly!(MyAssembly())\n\n\n\n\n\n","category":"type"},{"location":"lib/Composition.html#Modia3D.Composition.PointGravityField","page":"Composition","title":"Modia3D.Composition.PointGravityField","text":"PointGravityField([mass|;mue=G*EarthMass])\n\nReturn a PointGravityField struct with the gravity field constant mue (mue = G*mass).\n\nExample\n\nimport Modia3D\n\ngrav = Modia3D.PointGravityField()   # Gravity field of earth\n   r = Modia3D.EarthRadius\n   g = gravityAcceleration(grav,r)\n\n\n\n\n\n","category":"type"},{"location":"lib/Composition.html#Modia3D.Composition.SceneOptions","page":"Composition","title":"Modia3D.Composition.SceneOptions","text":"sceneOptions = Modia3D.SceneOptions(;kwargs...)\n\nDefine global options for a simulation of the scene with keyword arguments:\n\nKeyword arguments defaults\nenableContactDetection true\nelasticContactReductionFactor 1.0\ngravityField Modia3D.UniformGravityField()\nenableVisualization true\nvisualizeGravity true\nvisualizeFrames false\nvisualizeConvexHulls true\nvisualizeContactPoints false\nvisualizeSupportPoints false\nnominalLength 1.0\ndefaultFrameLength 0.2*nominalLength\ndefaultJointLength nominalLength/10\ndefaultJointWidth nominalLength/20\ndefaultForceLength nominalLength/10\ndefaultForceWidth nominalLength/20\ndefaultBodyDiameter nominalLength/9\ndefaultWidthFraction 20\ndefaultArrowDiameter nominalLength/40\ndefaultN_to_m 1000\ndefaultNm_to_m 1000\nuseOptimizedStructure true\ndefaultContactSphereDiameter 0.1\ncontactDetection ContactDetectionMPR_handler()\n\nOptional keyword arguments\n\nenableContactDetection::Bool: = true, if contact detection is enabled\nelasticContactReductionFactor::Float64: usedcontactcompliance = contact_compliance * elasticContactReductionFactor (> 0).\ngravityField::Modia3D.AbstractGravityField: Type of gravity field, such as: Modia3D.NoGravityField, Modia3D.UniformGravityField, Modia3D.PointGravityField.\nenableVisualization::Bool: = true, if animation is enabled\nvisualizeGravity::Bool: = true, if gravity field shall be visualized (acceleration vector or field center)\nvisualizeFrames::Bool: = true, if all frames shall be visualized\nvisualizeConvexHulls::Bool: = true, if convex hulls (used for contact detection) shall be visualized\nvisualizeContactPoints::Bool: = true, if contact points shall be visualized\nvisualizeSupportPoints::Bool = true, if support points shall be visualized\nnominalLength::Float64: [m] Nominal length of 3D system\ndefaultFrameLength::Float64: [m] Default for frame length if visualizeFrames = true (but not world frame)\ndefaultJointLength::Float64: [m] Default for the fixed length of a shape representing a joint\ndefaultJointWidth::Float64:  [m] Default for the fixed width of a shape representing a joint\ndefaultForceLength::Float64: [m] Default for the fixed length of a shape representing a force (e.g., damper)\ndefaultForceWidth::Float64:  [m] Default for the fixed width of a shape representing a force (e.g., spring, bushing)\ndefaultBodyDiameter::Float64: [m] Default for diameter of sphere representing the center of mass of a body\ndefaultWidthFraction::Float64: Default for shape width as a fraction of shape length\ndefaultArrowDiameter::Float64: [m] Default for arrow diameter (e.g., of forces, torques, sensors)\ndefaultN_to_m::Float64: [N/m] Default scaling of force arrows (length = force/defaultNtom)\ndefaultNm_to_m::Float64: [N.m/m] Default scaling of torque arrows (length = torque/defaultNmtom)\nuseOptimizedStructure::Bool: = true, if the optimized structure (with super objects, and common inertia) is used\ndefaultContactSphereDiameter::Float64: [m] Diameter of sphere used for contact point visualization\ncontactDetection::Modia3D.AbstractContactDetection: Handler used for contact detection (for example to determine the smallest distance between two objects).\n\nExample\n\nFor all the details see \"Modia3D/examples/dynamics/Simulate_Pendulum.jl\":\n\n\n@assembly Pendulum(;Lx = 1.0) begin\n   ...\nend\n\npendulum = Pendulum(Lx=1.6, sceneOptions=\n             Modia3D.SceneOptions(visualizeFrames=true, defaultFrameLength=0.3))\nmodel    = Modia3D.SimulationModel( pendulum )\nresult   = ModiaMath.simulate!(model, stopTime=4.5)\n\n\n\n\n\n","category":"type"},{"location":"lib/Composition.html#Modia3D.Composition.SimulationModel","page":"Composition","title":"Modia3D.Composition.SimulationModel","text":"simModel = SimulationModel(assembly::Modia3D.AbstractAssembly;\n                           analysis::ModiaMath.AnalysisType=ModiaMath.DynamicAnalysis,\n                           startTime = 0.0, stopTime  = 1.0, tolerance = 1e-4,\n                           interval  = (stopTime-startTime)/500.0,\n                           maxStepSize = NaN, maxNumberOfSteps=missing)\n\nGenerate a simulationModel from an assembly generated with macro Modia3D.@assembly and the type of analysis to be carried out on the assembly. Additionally, default startTime, stopTime, tolerance, interval, maxStepSize, maxNumberOfSteps, for the simulation engine are defined. These values should be adapted so that assembly-specific, meaningful defaults are provided.\n\n\n\n\n\n","category":"type"},{"location":"lib/Composition.html#Modia3D.Composition.UniformGravityField","page":"Composition","title":"Modia3D.Composition.UniformGravityField","text":"UniformGravityField(;g=9.81, n=[0,1,0])\n\nReturn a UniformGravityField struct.\n\nArguments\n\ng::Float64: Gravity constant\nn::AbstractVector: Direction of gravity\n\nExample\n\nimport Modia3D\n\ngrav = Modia3D.UniformGravityField()\n   r = Modia3D.EarthRadius\n   g = gravityAcceleration(grav,r)\n\n\n\n\n\n","category":"type"},{"location":"lib/Composition.html#Modia3D.Composition.Fixed-Tuple{Object3D,Object3D}","page":"Composition","title":"Modia3D.Composition.Fixed","text":"joint = Modia3D.Fixed(obj1, obj2; r=zeros(3), R=nothing, q=nothing)\n\nReturn a Fixed joint that fixes obj2::Object3D relatively to obj1::Object3D via the relative position vector from obj1 to obj2 (resolved in obj1) and the relative transformation matrix R from obj1 to obj2 or alternatively the relative quaternion q.\n\nArguments\n\nobj1::Object3D: Parent object.\nobj2::Object3D: Object fixed relative to obj1.\nr::AbstractVector: Relative position vector from obj1 to obj2  resolved in obj1.\nR::Union{ModiaMath.RotationMatrix,Nothing}: Rotation matrix defining the rotation  from obj1 to obj. If both R = nothing and q = nothing,  a null rotation is defined.\nq::Union{ModiaMath.Quaternion,Nothing}: Quaternion defining the rotation  from obj1 to obj2. If both R = nothing and q = nothing,  a null rotation is defined.\n\n\n\n\n\n","category":"method"},{"location":"lib/Composition.html#Modia3D.Composition.Prismatic-Tuple{Object3D,Object3D}","page":"Composition","title":"Modia3D.Composition.Prismatic","text":"joint = Modia3D.Prismatic(obj1::Object3D, obj2::Object3D;\n                          axis=1, s_start=0, v_start=0, canCollide=false)\n\nReturn a joint object that constrains the movement of obj2::Object3D with respect to obj1::Object3D along coordinate axis axis (axis = 1,2,3,-1,-2,-3). The initial position/velocity of obj2 with respect to obj1 along axis is s_start [m] and v_start [m/s], respectively. If canCollide=false, no collision detection will occur between obj1 and obj2 (and Object3Ds that are directly or indirectly rigidly fixed to obj1 or obj2).\n\nIf a Prismatic joint closes a kinematic loop, then the already present objects must be consistent to the Prismatic joint that is the frames of obj1 and obj2 must be parallel to each other and movement of obj1 along its axis axis with s_start results in obj2. If s_start=NaN, its value is computed in this case.\n\nExamples\n\nusing Modia3D\nimport ModiaMath\n\n@assembly FallingBall(;h=1.0) begin\n   world  = Object3D()\n   sphere = Object3D( Modia3D.Solid(Modia3D.SolidSphere(0.1), \"Aluminium\") )\n\n   # Constrain sphere movement (initial placement at position [0,h,0])\n   prismatic = Modia3D.Prismatic(world, sphere, axis=2, s_start=h)\nend\n\nsimulationModel = Modia3D.SimulationModel( FallingBall(h=1.5), stopTime=1.0 )\nresult          = ModiaMath.simulate!(simulationModel)\nModiaMath.plot(result, (\"prismatic.s\", \"prismatic.v\"))\n\n\n\n\n\n","category":"method"},{"location":"lib/Composition.html#Modia3D.Composition.Revolute-Tuple{Object3D,Object3D}","page":"Composition","title":"Modia3D.Composition.Revolute","text":"joint = Modia3D.Revolute(obj1, obj2; axis=3, phi_start=0, w_start=0, canCollide=false, J=NaN)\n\nReturn a Revolute joint that rotates obj1::Object3D into obj2::Object3D along the axis axis of obj1 (axis = 1,2,3,-1,-2,-3). The initial start angle is phi_start and the initial angular velocity is w_start. If canCollide=false, no collision detection will occur between obj1 and obj2 (and Object3Ds that are directly or indirectly rigidly fixed to obj1 or obj2).\n\nOptionally, an inertia can be placed on the axis of rotation (J). If such an inertia is provided, the generalized coordinate is still the angle of the revolute joint and the driving torque is still the torque acting in the revolute joint. If, for example, an electric motor with a gearbox shall be modelled then\n\nJ = JMotor*gearRatio^2\njointTorque = motorTorque*gearRatio\nmotor\n\n``J = JMotor*gearRatio^2; jointTorque =.\n\nIf a Revolute joint closes a kinematic loop, then the already present objects must be consistent to the Revolute joint. That is, the frames of obj1 and obj2 must be parallel to each other and rotating obj1 along its axis axis with phi_start results in obj2. If phi_start=NaN, its value is computed in this case.\n\nExamples\n\nusing Modia3D\nimport ModiaMath\n\n@assembly Pendulum(;L=1.0) begin\n   world  = Modia3D.Object3D()\n   obj1 = Modia3D.Object3D()\n   rev    = Modia3D.Revolute(world, obj1)\n   sphere = Modia3D.Object3D(obj1, Modia3D.Solid(Modia3D.SolidSphere(0.1), \"Aluminium\"),\n                             r = [L,0,0] )\nend\n\nsimulationModel = Modia3D.SimulationModel( Pendulum(L=0.8), stopTime=5.0 )\nresult          = ModiaMath.simulate!(simulationModel)\nModiaMath.plot(result, (\"rev.phi\", \"rev.w\"))\n\n\n\n\n\n","category":"method"},{"location":"lib/Composition.html#Modia3D.Composition.contactStart-Tuple{Modia3D.Solids.ElasticContactPairMaterial,Object3D,Object3D,StaticArrays.SArray{Tuple{3},Float64,1,3},StaticArrays.SArray{Tuple{3},Float64,1,3},Float64}","page":"Composition","title":"Modia3D.Composition.contactStart","text":"resonseMaterial = contactStart(matPair::Modia3D.ElasticContactPairMaterial,                                   obj1,obj2,rContact,contactNormal)\n\nReturn a responseMaterial::ElasticContactPairResponseMaterial object at the start of a collision.\n\n\n\n\n\n","category":"method"},{"location":"lib/Composition.html#Modia3D.Composition.contactStart-Tuple{Object3D,Object3D,StaticArrays.SArray{Tuple{3},Float64,1,3},StaticArrays.SArray{Tuple{3},Float64,1,3},Float64}","page":"Composition","title":"Modia3D.Composition.contactStart","text":"responseMaterial = contactStart(obj1, obj2, rContact, contactNormal)\n\nReturn a response material object at contact start.\n\n\n\n\n\n","category":"method"},{"location":"lib/Composition.html#Modia3D.Composition.distance-Tuple{Object3D,Object3D}","page":"Composition","title":"Modia3D.Composition.distance","text":"d = distance(frame1, frame2)\n\nReturn the distance between the origin of frame1 and the origin of frame2\n\n\n\n\n\n","category":"method"},{"location":"lib/Composition.html#Modia3D.Composition.normalRelativeVelocityAtContact-Tuple{Object3D,Object3D,StaticArrays.SArray{Tuple{3},Float64,1,3},StaticArrays.SArray{Tuple{3},Float64,1,3}}","page":"Composition","title":"Modia3D.Composition.normalRelativeVelocityAtContact","text":"delta_dot = normalRelativeVelocityAtContact(obj1, obj2, rContact, contactNormal)\n\nReturn the relative velocity in normal direction contactNormal at contact point rContact of the two penetrating objects obj1, obj2.\n\n\n\n\n\n","category":"method"},{"location":"lib/Composition.html#Modia3D.Composition.planarRotationAngle-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Composition","title":"Modia3D.Composition.planarRotationAngle","text":"angle = planarRotationAngle(e, v1, v2)\n      = planarRotationAngle(frame1, frame2)\n\nReturn angle of a planar rotation, given the rotation axis e (a unit vector) and the representations of a vector in frame 1 (v1) and frame 2 (v2).\n\nUnder the assumption that the z-axes of frame1 and frame2 coincide, return the angle between the x-axis of frame1 and the position vector from frame1 to frame2.\n\n\n\n\n\n","category":"method"},{"location":"lib/Composition.html#Modia3D.Composition.responseCalculation-Tuple{Modia3D.Composition.ElasticContactPairResponseMaterial,Object3D,Object3D,StaticArrays.SArray{Tuple{3},Float64,1,3},StaticArrays.SArray{Tuple{3},Float64,1,3},Float64,Float64,Any}","page":"Composition","title":"Modia3D.Composition.responseCalculation","text":"(f1,f2,t1,t2) = responseCalculation(material::ElasticContactPairResponseMaterial,\n                        obj1, obj2, rContact, contactNormal, distanceWithHysteresis, time)\n\nCompute contact forces f1,f2 and contact torques t1,t2 from the elastic contact pair response material material the two penetrating objects obj1, obj2, the contact point rContact, the contact normal contactNormal and the largest penetration depth distanceWithHysteresis at time time.\n\n\n\n\n\n","category":"method"},{"location":"lib/Composition.html#Modia3D.Composition.visualizeAssembly!-Tuple{Modia3D.AbstractAssembly}","page":"Composition","title":"Modia3D.Composition.visualizeAssembly!","text":"visualizeAssembly!(assembly::Modia3D.AbstractAssembly)\n\nVisualize the assembly defined with macro Modia3D.@assembly in its initial configuration (but without simulating it).\n\n\n\n\n\n","category":"method"},{"location":"lib/Composition.html#Modia3D.Composition.@assembly-Tuple{Any,Any}","page":"Composition","title":"Modia3D.Composition.@assembly","text":"@assembly AssemblyName(arguments) begin ... end\n\nReturn the constructor for a new struct AssemblyName consisting of Object3Ds that are connected together. The new struct consists of all left-hand-side (scalar or vector) symbols present between begin ... end.\n\nExamples\n\nusing Modia3D\n\n@assembly Bar(;Lx = 0.1, Ly=Lx/5, Lz=Ly) begin\n   frame0 = Modia3D.Object3D(Modia3D.Solid(Modia3D.SolidBeam(Lx,Ly,Lz), nothing, vmat1))\n   frame1 = Modia3D.Object3D(frame0; r=[-Lx/2, 0.0, 0.0])\n   frame2 = Modia3D.Object3D(frame0; r=[ Lx/2, 0.0, 0.0])\n   cyl1   = Modia3D.Object3D(frame1, cyl)\n   cyl2   = Modia3D.Object3D(frame2, cyl)\nend\nbar = Bar(;Lx=1.0)\nModia3D.visualizeAssembly!( bar )\n\n\n\n\n\n","category":"macro"},{"location":"lib/Graphics.html#Graphics-1","page":"Graphics","title":"Graphics","text":"","category":"section"},{"location":"lib/Graphics.html#","page":"Graphics","title":"Graphics","text":"Modules = [Modia3D.Graphics]\r\nPrivate = false","category":"page"},{"location":"lib/Graphics.html#Modia3D.Graphics","page":"Graphics","title":"Modia3D.Graphics","text":"module Modia3D.Graphics\n\nVisual elements used for animation. The visual elements are passed to an external renderer. Currently, the (free) community edition and the (commercial) professional editions of the DLR Visualization library are supported (not all visualization elements of this library are yet interfaced to Modia3D). Modia3D is designed so that other renderers can be supported as well.\n\nVisualization elements with geometry and visualization material:\n\n(Image: VisuElements)\n\nVisualization elements that do not have a visualization material:\n\n(Image: VisuElementsWithout)\n\nMain developers\n\nAndrea Neumayr and Martin Otter, DLR - Institute of System Dynamics and Control ```\n\n\n\n\n\n","category":"module"},{"location":"lib/Graphics.html#Modia3D.Graphics.colorPalette","page":"Graphics","title":"Modia3D.Graphics.colorPalette","text":"const colorPalette\n\nDictionary with default colors.\n\n\n\n\n\n","category":"constant"},{"location":"lib/Graphics.html#Modia3D.Graphics.Font","page":"Graphics","title":"Modia3D.Graphics.Font","text":"font = Modia3D.Font(;fontFamily=\"FreeSans\", bold=false, italic=false, charSize=0.1,\n                     color=\"LightBlue\", transparency=0.0)\n\nReturn a Font definition.\n\nArguments\n\nfontFamily::String: Font family (\"FreeSans\", \"FreeSerif\", \"Arial\", \"ArialNarrow\", \"CourierNew\", \"TimesNewRoman\", or \"Verdana\").\nbold::Bool: = true, if bold font.\nitalic::Bool: = true, if italic font.\ncharSize::Number: Character size in [m].\ncolor::Modia3D.RGBColor: Color; Examples: rgb(\"Blue\"), rgb([0,0,255]), rgb(0,0,255).\ntransparency::Number: 0.0 (opaque) ... 1.0 (transparent)\n\nExamples\n\nimport Modia3D\nfont1 = Modia3D.Font()\nfont2 = Modia3D.Font(fontFamily=\"Arial\", bold=true, charSize=0.2, \n                     color=\"LightBlue\", transparency=0.5)\n\n\n\n\n\n","category":"type"},{"location":"lib/Graphics.html#Modia3D.Graphics.Material","page":"Graphics","title":"Modia3D.Graphics.Material","text":"material = Modia3D.Material(;color=defaultColor(), wireframe=false, transparency=0.0,\n                             reflectslight=true, shininess=0.7, \n                             shadowMask=CastsAndReceivesShadows))\n\nReturn a material object that defines attributes for the visualization of an Object3D  that has visual or solid properties.\n\nArguments\n\ncolor: This argument is passed to function Modia3D.rgb(color) to return the RGB color value in          form of a vector. E.g. color=\"Red\" or color=[255,0,0].\nwireframe: = false, if solid, otherwise wireframe representation.\ntransparency: = 0.0 (opaque) ... 1.0 (fully transparent).\nreflectslight: = true if it reflects light and false, if it does not reflect light.\nshininess: = 0.0 (matte surface) ... 1.0 (very shiny surface).\nshadowMask: defines whether or not an object casts or receives shadows. Possible values:  NoShadows, CastsShadows, ReceivesShadows, CastsAndReceivesShadows.\n\n\n\n\n\n","category":"type"},{"location":"lib/Graphics.html#Modia3D.Graphics.TextShape","page":"Graphics","title":"Modia3D.Graphics.TextShape","text":"textShape = Modia3D.TextShape(text; font=Modia3D.Font(), offset=[0.0,0.0,0.0], \n                      axisAlignment=Modia3D.Screen, alignment=Modia3D.Center)\n\nReturn a text shape.\n\nArguments\n\ntext::AbstractString: String of the text.\nfont::Modia3D.Font: Font of the text.\noffset::AbstractVector: Offset from origin to text alignment point.\naxisAlignment::Modia3D.AxisAlignment: Alignment of Text (parallel to screen or in  planes of frame: = Modia3D.Screen, Modia3D.XYPlane, Modia3D.XZPlane, Modia3D.YZ_Plane).\naxisAlignment::Modia3D.Alignment: Alignment of Text relative to its origin (= Modia3D.Left, Modia3D.Right or Modia3D.Center).\n\nExamples\n\nimport Modia3D\nfont  = Modia3D.Font(fontFamily=\"Arial\", charSize=0.4, color=Modia3D.rgb(\"Red\"))\ntext1 = Modia3D.TextShape(\"This is a box\")\ntext2 = Modia3D.TextShape(\"This is the xy plane\";\n                          font=font, axisAlignment=Modia3D.XY_Plane, \n                          alignment=Modia3D.Left)\n\n\n\n\n\n","category":"type"},{"location":"lib/Graphics.html#Modia3D.Graphics.rgb-Tuple{String}","page":"Graphics","title":"Modia3D.Graphics.rgb","text":"color = rgb([name::String | vec::AbstractVector | r::Number,g::Number,b::Number])\n\ndefines the color as a 3-vector of RGB values. Currently, the following names of colors are defined: Black, DarkRed, Red, LightRed, DarkGreen, Green, LightGreen, DarkBlue, Blue, LightBlue, Yello, Pink DarkGrey, Grey, White.\n\nExamples\n\ncolor1 = Modia3D.rgb(\"Red\")       # = [255,0,0]\ncolor2 = Modia3D.rgb([255,0,0])   # = [255,0,0]\ncolor3 = Modia3D.rgb(255,0,0)     # = [255,0,0]\n\n\n\n\n\n","category":"method"},{"location":"lib/Graphics.html#","page":"Graphics","title":"Graphics","text":"","category":"page"},{"location":"lib/Solids.html#Solids-1","page":"Solids","title":"Solids","text":"","category":"section"},{"location":"lib/Solids.html#","page":"Solids","title":"Solids","text":"Modules = [Modia3D.Solids]\r\nPrivate = false","category":"page"},{"location":"lib/Solids.html#Modia3D.Solids","page":"Solids","title":"Modia3D.Solids","text":"module Modia3D.Solids\n\nModule Solids provides data structures and operations for solids, so objects that have a volume and properties associated with the volume. Solid parts can be associated with a Modia3D.Object3D. They are defined with struct Modia3D.Solid consisting of an optional solid geometry:\n\n(Image: Solids)\n\nand other optional properties:\n\nmass propreties (defined by geometry+material-name, geometry+density, or directly defined mass properties),\ncontact material (for elastic response calculation),\nvisualization material (for visualization, see below).\n\nSince the solid geometry itself is optional, it is possible to just define a coordinate system with associated mass, center of mass and inertia matrix.\n\nThe following functions are provided for a solid geometry geo::Modia3D.AbstractSolidGeometry that is associated with an Object3D object3D:\n\nModia3D.volume(geo) returns the volume of geo.\nModia3D.centroid(geo) returns the centroid of geo (= center of mass for uniform density).\nModia3D.inertiaMatrix(geo, mass) returns the inertia matrix of geo.\nModia3D.boundingBox!(geo, <other arguments>) returns the Axis Aligned Bounding Box of geo.\nModia3D.supportPoint(geo, <other arguments>) returns the support point of geo along the desired direction.\nisVisible(object3D, renderer),\ndataHasMass(object3D),\ncanCollide(object3D),\nand other functions.\n\nOther functions in module Solids:\n\nModia3D.SolidMaterial(name) returns the solid properties of material name.\n\nMain developers\n\nAndrea Neumayr and Martin Otter, DLR - Institute of System Dynamics and Control\n\n\n\n\n\n","category":"module"},{"location":"lib/Solids.html#Modia3D.Solids.contactPairMaterialPalette","page":"Solids","title":"Modia3D.Solids.contactPairMaterialPalette","text":"contactPairMaterialPalette\n\nDictionary of contact pair material data, see Modia3D.ElasticContactPairMaterial\n\n\n\n\n\n","category":"constant"},{"location":"lib/Solids.html#Modia3D.Solids.solidMaterialPalette","page":"Solids","title":"Modia3D.Solids.solidMaterialPalette","text":"const solidMaterialPalette\n\nDictionary of solid material data, see Modia3D.SolidMaterial\n\n\n\n\n\n","category":"constant"},{"location":"lib/Solids.html#Modia3D.Solids.ElasticContactPairMaterial","page":"Solids","title":"Modia3D.Solids.ElasticContactPairMaterial","text":"material = ElasticContactPairMaterial(;coefficientOfRestitution=0.0, slidingFrictionCoefficient=0.0,\n                                       rotationalResistanceCoefficient=0.0, vsmall=0.01, wsmall=0.01)\n\nGenerates an ElasticContactPairMaterial object by providing the material properties of two objects that are in contact to each other.\n\nKeyword Arguments\n\ncoefficientOfRestitution: Coefficient of restitution between two objects (=0: inelastic ... =1: fully elastic).\nslidingFrictionCoefficient: Kinetic/sliding friction force coefficent between two objects (>= 0.0).\nrotationalResistanceCoefficient: Rotational resistance torque coefficient between two objects (>= 0.0). Its effect is that the contact torque is computed to reduce the relative angular velocity between two objects. For a ball, rotationalResistanceCoefficient is the (standard) rolling resistance coefficient.\nvsmall in [m/s]: Used for regularization when computing the unit vector in direction of                    the relative tangential velocity to avoid a division by zero.\nwsmall in [rad/s]: Used for regularization when computing the unit vector in direction                      of the relative angular velocity to avoid a division by zero.\n\nExample\n\nimport Modia3D\nmat = Modia3D.ElasticContactPairMaterial(coefficientOfRestitution=0.5)\n\n\n\n\n\n","category":"type"},{"location":"lib/Solids.html#Modia3D.Solids.Solid","page":"Solids","title":"Modia3D.Solids.Solid","text":"solid = Modia3D.Solid([geo | nothing],\n                      [solidMaterialName | solidMaterial | mass |\n                       massProperties    | nothing] = nothing,\n                      [material = Modia3D.Material() | nothing];\n                      contactMaterial=nothing)\n\nGenerate a new (rigid) solid with optional solid geometry, mass, visualization and collision properties A solid can be associated to a Modia3D.Object3D.\n\nArguments\n\ngeo::Union{Modia3D.AbstractSolidGeometry,NOTHING}: Optional solid geometry object (such as Modia3D.SolidSphere,.SolidBox,.SolidFileMesh).\nMass properties (mass, center of mass, inertia matrix) of geo are computed by one of:\nsolidMaterialName::AbstractString: Name of a solid material defined in dictionary Modia3D.solidMaterialPalette (computed by geo and density of solid material)\nsolidMaterial::Modia3D.SolidMaterial: Solid material properties object (computed by geo and solidMaterial.density)\nmass::Number: Mass in kg (computed by geo and mass).\nmassProperties::Modia3D.MassProperties: Mass properties (mass, center of mass, inertia matrix) are explicitly given.\nnothing: geo has no mass.\nmaterial::Union{Modia3D.Material,NOTHING}: Visualization material of geo.  If material=nothing, geo is not shown in the visualization.\ncontactMaterial::Union{Modia3D.AbstractContactMaterial,NOTHING}: Contact material of geo.  If contactMaterial=nothing, no collision handling takes place for geo.\n\n(Image: Solids)\n\nExamples\n\nimport Modia3D\n\nsbox  = Modia3D.SolidBox(1.0,2.0,3.0)\nsmat  = Modia3D.SolidMaterial(density = 2700)\nvmat  = Modia3D.Material(color=\"Blue\", transparency=0.5)\ncmat  = Modia3D.ContactMaterialElastic(c=1e5, d=100)\nmassProperties = Modia3D.MassProperties(m=0.1, Ixx=1.0, Iyy=2.0, Izz=3.0)\n\nsolid1 = Modia3D.Solid(sbox, \"Aluminium\", vmat)\nsolid2 = Modia3D.Solid(sbox, smat       , vmat)\nsolid3 = Modia3D.Solid(sbox, 2.1        , vmat )\nsolid4 = Modia3D.Solid(sbox, nothing; contactMaterial=cmat)\nsolid5 = Modia3D.Solid(Modia3D.SolidSphere(0.1), massProperties, vmat; contactMaterial=cmat)\nsolid6 = Modia3D.Solid(nothing, massProperties)\n\n\n\n\n\n","category":"type"},{"location":"lib/Solids.html#Modia3D.Solids.SolidMaterial","page":"Solids","title":"Modia3D.Solids.SolidMaterial","text":"material = SolidMaterial(;kwargs...)\n\nGenerates a SolidMaterial object by providing the material properties of a solid with keyword arguments. Arguments that are not provided have value = NaN.\n\nKeyword Arguments\n\ndensity in [kg/m^3]: Density, see Wikipedia.\nYoungsModulus in [Pa]: Youngs's modulus, see Wikipedia.\nPoissonsRatio: Poisson's ratio, see Wikipedia.\nmeltingPoint in [K]: Melting point, see Wikipedia.                        If the material is destroyed before its melting point (e.g. wood that is burning)                       then meltingPoint is the temperature when destruction of the solid starts.\nspecificHeatCapacity in [J/(kg.K)]: Specific heat capacity, see Wikipedia.\nthermalConductivity in [W/(m.K)]: Thermal conductivity, see Wikipedia and                               List of thermal conductivities\nlinearThermalExpansionCoefficient::Float64 in [1/K]: Linear thermal expansion coefficient, see Wikipedia.\n\nExample\n\nimport Modia3D\nmat1 = Modia3D.SolidMaterial(density=3000.0, YoungsModulus=2e11)\n\n\n\n\n\n","category":"type"},{"location":"lib/Solids.html#Modia3D.Solids.boundingBox!-Tuple{Modia3D.AbstractSolidGeometry,Modia3D.Basics.BoundingBox,AbstractArray{T,1} where T,AbstractArray{T,2} where T}","page":"Solids","title":"Modia3D.Solids.boundingBox!","text":"boundingBox!(geo, AABB, r_abs, R_abs; tight=true, scaleFactor=0.01)\n\nReturns the Axis Aligned Bounding Box of solid geo in argument AABB.\n\nArguments\n\ngeo::Modia3D.AbstractSolidGeometry: Solid geometry object.\nAABB::Modia3D.BoundingBox: On return, update AABB with the actual Axis Aligned Bounding Box of solid geo.\nr_abs::AbstractVector: Absolute position vector of geo reference frame.\nR_abs::AbstractMatrix: Rotation matrix to rotate world frame in geo reference frame.\ntight::Bool: If true, return the tightest AABB. If false return an AABB that is               scaleFactor bigger than the best fitting AABB               (for example, scaleFactor=0.1 means that the returned AABB is 10 percent bigger               than the best fitting AABB).\nscaleFactor::Float64: If tight=false, the returned AABB is scaleFactor bigger than the                         best fitting AABB.\n\n\n\n\n\n","category":"method"},{"location":"lib/Solids.html#Modia3D.Solids.centroid-Tuple{Modia3D.AbstractSolidGeometry}","page":"Solids","title":"Modia3D.Solids.centroid","text":"r = centroid(geo)\n\nReturn position vector from solid reference frame to centroid of solid geo::Modia3D.AbstractSolidGeometry in [m]. If the solid has a uniform density, the centroid is identical to the center of mass.\n\n\n\n\n\n","category":"method"},{"location":"lib/Solids.html#Modia3D.Solids.inertiaMatrix-Tuple{SolidSphere,Number}","page":"Solids","title":"Modia3D.Solids.inertiaMatrix","text":"I = inertiaMatrix(geo, mass)\n\nReturn inertia matrix I of solid geo::Modia3D.AbstractSolidGeometry with respect to the solid reference frame in [kg*m^2] as SMatrix{3,3,Float64,9}. Hereby it is assumed that geo has uniform density and mass is the mass of geo in [kg].\n\n\n\n\n\n","category":"method"},{"location":"lib/Solids.html#Modia3D.Solids.supportPoint-Tuple{Modia3D.AbstractSolidGeometry,AbstractArray{T,1} where T,AbstractArray{T,2} where T,AbstractArray{T,1} where T}","page":"Solids","title":"Modia3D.Solids.supportPoint","text":"r = supportPoint(geo, r_abs, R_abs, e)\n\nReturn the absolute position vector r from world frame to support point of solid geo, resolved in world frame in [m]. The support point is the point of solid geo that is the most extreme in direction of unit vector e.\n\nArguments\n\ngeo::Modia3D.AbstractSolidGeometry: Solid geometry object.\nr_abs::AbstractVector: Absolute position vector of geo reference frame.\nR_abs::AbstractMatrix: Rotation matrix to rotate world frame in geo reference frame.\ne::AbstractVector: Unit vector pointing into the desired direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/Solids.html#Modia3D.Solids.volume-Tuple{Modia3D.AbstractSolidGeometry}","page":"Solids","title":"Modia3D.Solids.volume","text":"V = volume(geo)\n\nReturn the volume of the solid geometry geo::Modia3D.AbstractSolidGeometry in [m^3].\n\n\n\n\n\n","category":"method"},{"location":"lib/ForceElements.html#ForceElements-1","page":"ForceElements","title":"ForceElements","text":"","category":"section"},{"location":"lib/ForceElements.html#","page":"ForceElements","title":"ForceElements","text":"Modules = [Modia3D.ForceElements]\r\nPrivate = false","category":"page"},{"location":"lib/ForceElements.html#Modia3D.ForceElements","page":"ForceElements","title":"Modia3D.ForceElements","text":"module Modia3D.ForceElements\n\nElements generating forces or torques that act on objects.\n\nMain developers\n\nAndrea Neumayr and Martin Otter, DLR - Institute of System Dynamics and Control\n\n\n\n\n\n","category":"module"},{"location":"lib/ForceElements.html#Modia3D.ForceElements.@forceElement-Tuple{Any,Any}","page":"ForceElements","title":"Modia3D.ForceElements.@forceElement","text":"@forceElement forceName(arguments) begin ... end - Generate a function that instantiates a new forceElement\n\nforceName(arguments) begin ... end is treated as the constructor function of a new (mutable) struct that consists of all left-hand-side (scalar or vector) symbols present between begin ... end.\n\nExamples\n\njulia> include(\"D:\\otter\\home\\.julia\\dev\\Modia3D/examples/dynamics/Simulate_PendulumWithDamper.jl\");\n\nusing ModiaMath\nusing Modia3D\n\n@forceElement Damper(; d=1.0) begin\n    w   = ModiaMath.RealScalar(\"w\",   causality=ModiaMath.Input,  numericType=ModiaMath.WR)\n    tau = ModiaMath.RealScalar(\"tau\", causality=ModiaMath.Output, numericType=ModiaMath.WR)\nend;\nfunction Modia3D.computeTorque(damper::Damper, sim::ModiaMath.SimulationState)\n    damper.tau.value = -damper.d*damper.w.value\nend;\n@assembly PendulumWithDamper(;Lx = 1.0, Ly=0.2*Lx, Lz=0.2*Lx, m=1.0, g=9.81) begin\n   world  = Modia3D.Object3D(Modia3D.CoordinateSystem(0.5*Lx))\n   body   = Modia3D.Object3D(Modia3D.Solid(Modia3D.SolidBeam(Lx,Ly,Lz), Modia3D.MassProperties(m=m), vmat1))\n   frame1 = Modia3D.Object3D(body; r=[-Lx/2, 0.0, 0.0])\n   cyl    = Modia3D.Object3D(frame1,Modia3D.Cylinder(Ly/2,1.2*Ly; material=vmat2))\n\n   # Connect pendulum to world with a damper in the joint\n   rev    = Modia3D.Revolute(world, frame1)\n   d      = Damper(d=0.2)\n   damper = Modia3D.AdaptorForceElementToFlange(w=d.w, tau=d.tau)\n   Modia3D.connect(damper, rev)\nend\npendulum = PendulumWithDamper()\nmodel = Modia3D.SimulationModel( pendulum )\nresult = ModiaMath.simulate!(model, stopTime=5.0, interval=0.1, tolerance=1e-4, log=true)\nModiaMath.plot(result, [\"rev.phi\", \"rev.w\", \"rev.a\", \"rev.tau\"])\n\n\n\n\n\n","category":"macro"},{"location":"lib/ForceElements.html#","page":"ForceElements","title":"ForceElements","text":"","category":"page"},{"location":"lib/Basics.html#Basics-1","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"lib/Basics.html#","page":"Basics","title":"Basics","text":"Modules = [Modia3D.Basics]\r\nPrivate = false","category":"page"},{"location":"lib/Basics.html#Modia3D.Basics","page":"Basics","title":"Modia3D.Basics","text":"module Modia3D.Basics\n\nUtility constants and functions for Modia3D\n\nMain developers\n\nAndrea Neumayr and Martin Otter, DLR - Institute of System Dynamics and Control\n\n\n\n\n\n","category":"module"},{"location":"lib/Basics.html#Modia3D.Basics.BoundingBox","page":"Basics","title":"Modia3D.Basics.BoundingBox","text":"mutable struct BoundingBox - Smallest box that contains a visual element\n\n\n\n\n\n","category":"type"},{"location":"lib/Basics.html#Modia3D.Basics.PTP_path","page":"Basics","title":"Modia3D.Basics.PTP_path","text":"path = PTP_path(names;\n                positions = [zeros(size(names,1))'; ones(size(names,1))'],\n                startTime=0.0,\n                v_max = ones(size(names,1)),\n                a_max = ones(size(names,2))))\n\nGenerate a new path object.\n\n\n\n\n\n","category":"type"},{"location":"lib/Basics.html#Modia3D.Basics.getAndCheckFullLibraryPath-Tuple{Any,Any}","page":"Basics","title":"Modia3D.Basics.getAndCheckFullLibraryPath","text":"getAndCheckFullLibraryPath(dir,libname)\n\nReturn joinpath(dir,libname). The returned full path must be a DLL. It is checked whether this DLL can be opened\n\n\n\n\n\n","category":"method"},{"location":"lib/Basics.html#Modia3D.Basics.getEnvironmentVariable-Tuple{String,String}","page":"Basics","title":"Modia3D.Basics.getEnvironmentVariable","text":"value = getEnvironmentVariable(name, description)\n\nReturns the value of the environment variable name.  If name does not exist, an error message is triggered:\n\nEnvironment variable <name> not defined\n(= <description>)\n\n\n\n\n\n","category":"method"},{"location":"lib/Basics.html#Modia3D.Basics.getIndex-Tuple{Any,Any}","page":"Basics","title":"Modia3D.Basics.getIndex","text":"index = getIndex(path, name)\n\nReturn the index of name in path or trigger an error, if not present.\n\n\n\n\n\n","category":"method"},{"location":"lib/Basics.html#Modia3D.Basics.getPosition!-Tuple{PTP_path,Number,Array{Float64,1}}","page":"Basics","title":"Modia3D.Basics.getPosition!","text":"getPosition!(path, time, position)\n\nGiven a path::PTP_path and a time instant time, return the actual position at time time in vector position.\n\n\n\n\n\n","category":"method"},{"location":"lib/Basics.html#Modia3D.Basics.getPosition-Tuple{PTP_path,Any,Number}","page":"Basics","title":"Modia3D.Basics.getPosition","text":"pos = getPosition(path, index, time)\n\nGiven a path::PTP_path, the index of a signal, and a time instant time, return the actual position at time time.\n\n\n\n\n\n","category":"method"},{"location":"lib/Basics.html#Modia3D.Basics.listKeys-Tuple{Any}","page":"Basics","title":"Modia3D.Basics.listKeys","text":"listKeys(dict)\n\nList the keys of dictionary dict in sorted order.\n\n\n\n\n\n","category":"method"},{"location":"lib/Basics.html#Modia3D.Basics.plotPath-Tuple{PTP_path}","page":"Basics","title":"Modia3D.Basics.plotPath","text":"plotPath(path;\n         names=path.names, heading=\"PTP plots\",\n         tend=1.1*path.Tend, figure=1, ntime=101)\n\nGiven a path::PTP_path, plot the path over time up to tend for all points identified by the vector or tuple names to figure figure using ntime time points.\n\n\n\n\n\n","category":"method"},{"location":"lib/Basics.html#Modia3D.Basics.readDictOfStructsFromJSON-Tuple{Any,Any}","page":"Basics","title":"Modia3D.Basics.readDictOfStructsFromJSON","text":"readDictOfStructsFromJSON(fileName, StructType)\n\nRead a JSON file from fileName and return a Dict{String, StructType} dictionary. StructType must be a mutable struct type with a constructor StructType().\n\n\n\n\n\n","category":"method"},{"location":"internal/ContactDetection.html#Contact-Detection-1","page":"Contact Detection","title":"Contact Detection","text":"","category":"section"},{"location":"internal/ContactDetection.html#Distances-1","page":"Contact Detection","title":"Distances","text":"","category":"section"},{"location":"internal/ContactDetection.html#","page":"Contact Detection","title":"Contact Detection","text":"In scene.options.contactDetection (file Modia3D/src/contactDetection/ContactDectionMPR_handler.jl) information about the contact situation is stored in an instance of Modia3D.Composition.ContactDetectionMPR_handler.","category":"page"},{"location":"internal/ContactDetection.html#","page":"Contact Detection","title":"Contact Detection","text":"The distance between two objects is defined by two variables:","category":"page"},{"location":"internal/ContactDetection.html#","page":"Contact Detection","title":"Contact Detection","text":"distanceOrg","category":"page"},{"location":"internal/ContactDetection.html#","page":"Contact Detection","title":"Contact Detection","text":"The original distance which is the distance between two objects computed either in the narrow phase or in an approximate way in the broad phase (= distance between Axis Aligned Bounding Boxes). If distanceOrg < 0, then the two objects are penetrating each other.","category":"page"},{"location":"internal/ContactDetection.html#","page":"Contact Detection","title":"Contact Detection","text":"distanceWithHysteresis","category":"page"},{"location":"internal/ContactDetection.html#","page":"Contact Detection","title":"Contact Detection","text":"The distance reported to the integrator as zero crossing function. If a zero crossing occurs (the value is changing from positive to negative or from negative to positive), an event is triggered and the time instant of the zero crossing is detected up to a certain precision. distanceWithHysteresis is a slightly modified value of distanceOrg in order to cope with numerical inaccuracies and in order to guarantee that this value is not identical to zero when restarting from the event (otherwise the integrator would trigger an error, because it would not be able to detect a zero crossing in the future). At an event instant (including initialization), the following flag is set and keeps its value until the next event (zEps = 1e-8):","category":"page"},{"location":"internal/ContactDetection.html#","page":"Contact Detection","title":"Contact Detection","text":"contact = distanceOrg < -zEps","category":"page"},{"location":"internal/ContactDetection.html#","page":"Contact Detection","title":"Contact Detection","text":"Whenever a zero crossing function computation is required by the integrator, the following value is provided to the integrator:","category":"page"},{"location":"internal/ContactDetection.html#","page":"Contact Detection","title":"Contact Detection","text":"distanceWithHysteresis = contact ? distanceOrg : distanceOrg + 2*zEps","category":"page"},{"location":"internal/ContactDetection.html#","page":"Contact Detection","title":"Contact Detection","text":"The result is the following:","category":"page"},{"location":"internal/ContactDetection.html#","page":"Contact Detection","title":"Contact Detection","text":"At initialization, contact = false if distanceOrg >= -zEps. Therefore, if two objects are touching each other or are slightly penetrating each other (e.g. distanceOrg = -1e-14), then this is not treated as contacting. Otherwise, contact = true.\nDuring simulation, an event is triggered if\ndistanceOrg becomes smaller as -2*zEps, if contact = false.\ndistanceOrg becomes larger as zero if contact = true.","category":"page"},{"location":"internal/ContactDetection.html#","page":"Contact Detection","title":"Contact Detection","text":"By this formulation it is guaranteed that distanceWithHysteresis is not identical to zero when starting after initialization or restarting after an event.","category":"page"},{"location":"internal/ContactDetection.html#Crossing-functions-1","page":"Contact Detection","title":"Crossing functions","text":"","category":"section"},{"location":"internal/ContactDetection.html#","page":"Contact Detection","title":"Contact Detection","text":"Modia3D uses the dictionary contactDict to keep track of the contact situation. Every pair of objects is identified by a unique Integer value called PairID that is used as key in conctactDict. A dictionary value is an instance of Modia3D.Composition.ContactPair","category":"page"},{"location":"internal/ContactDetection.html#","page":"Contact Detection","title":"Contact Detection","text":"At an event instant, dictionary contactDict is emptied and all object pairs are stored newly in contactDict that have distanceWithHysteresis < 0. Between events, contact forces/torques are only applied on object pairs that are in this dictionary.","category":"page"},{"location":"internal/ContactDetection.html#","page":"Contact Detection","title":"Contact Detection","text":"The following functions are used as zero crossing functions:","category":"page"},{"location":"internal/ContactDetection.html#","page":"Contact Detection","title":"Contact Detection","text":"z_1(t): The maximum distanceWithHysteresis of all object pairs that are in contactDict.\nz_2(t): The minimum distanceWithHysteresis of all object pairs that are not in contactDict.","category":"page"},{"location":"internal/ContactDetection.html#","page":"Contact Detection","title":"Contact Detection","text":"As a result z_1 monitors if an object pair that has been in contact, looses contact, so distanceWithHysteresis becomes greater than zero, and z_2 monitors if an object pair that has not been in contact, starts to penetrate each other, so distanceWithHysteresis becomes less than zero,","category":"page"},{"location":"internal/ContactDetection.html#","page":"Contact Detection","title":"Contact Detection","text":"Whenever the integrator requires the values of the zero crossing functions, the values of z_1 z_2 are newly computed. At all other time instants (e.g. communication points), only the distances of the object pairs are computed that are in dictionary contactDict, because these distances are used to compute the contact forces and torques. Distances of object pairs that are not in contact to each other are not computed at these time instant.","category":"page"},{"location":"internal/ContactDetection.html#","page":"Contact Detection","title":"Contact Detection","text":"Whenever contact starts for an object pair the normal contact velocity is stored in the value (of type Modia3D.Composition.ContactPair) of the dictionary. When a contact pair was already in contact at an event, it is necessary to utilize the normal contact velocity from the previous event also at the actual event. In order that this is possible, a second dictionary lastContactDict is used: Once contactDict is constructed at an event, a copy is stored in lastContactDict. At the next event, a new contactDict is constructed. Whenever an object pair is included in contactDict that is also present in lastContactDict, then the normal contact velocity stored in lastContactDict is utilized.","category":"page"}]
}
